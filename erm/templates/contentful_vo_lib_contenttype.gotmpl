// Code generated by https://github.com/foomo/gocontentful - DO NOT EDIT.
{{ $cfg := . }}{{ $contentTypes := .ContentTypes }}{{ $contentType := .ContentType }}package {{ .PackageName }}

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/foomo/contentful"
)

const ContentType{{ firstCap $contentType.Sys.ID }} = "{{ $contentType.Sys.ID }}"
// ---{{ firstCap $contentType.Sys.ID }} private methods---


// ---{{ firstCap $contentType.Sys.ID }} public methods---

func (cc *ContentfulClient) GetAll{{ firstCap $contentType.Sys.ID }}(ctx context.Context) (voMap map[string]*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc == nil {
		return nil, errors.New("GetAll{{ firstCap $contentType.Sys.ID }}: No client available")
	}
	cc.cacheMutex.sharedDataGcLock.RLock()
	cacheInit := cc.cacheInit
	optimisticPageSize := cc.optimisticPageSize
	cc.cacheMutex.sharedDataGcLock.RUnlock()
	if cacheInit {
		return cc.Cache.entryMaps.{{ $contentType.Sys.ID }}, nil
	}
	col, err := cc.optimisticPageSizeGetAll(ctx, "{{ $contentType.Sys.ID }}", optimisticPageSize)
	if err != nil {
		return nil, err
	}
	all{{ firstCap $contentType.Sys.ID }}, err := colToCf{{ firstCap $contentType.Sys.ID }}(col,cc)
	if err != nil {
		return nil, err
	}
	{{ $contentType.Sys.ID }}Map := map[string]*Cf{{ firstCap $contentType.Sys.ID }}{}
	for _, {{ $contentType.Sys.ID }} := range all{{ firstCap $contentType.Sys.ID }} {
		{{ $contentType.Sys.ID }}Map[{{ $contentType.Sys.ID }}.Sys.ID] = {{ $contentType.Sys.ID }}
	}
	return {{ $contentType.Sys.ID }}Map, nil
}

func (cc *ContentfulClient) GetFiltered{{ firstCap $contentType.Sys.ID }}(ctx context.Context, query *contentful.Query) (voMap map[string]*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc == nil || cc.Client == nil {
		return nil, errors.New("getFiltered{{ firstCap $contentType.Sys.ID }}: No client available")
	}
	col := cc.Client.Entries.List(ctx, cc.SpaceID)
	if query != nil {
		col.Query = *query
	}
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Include(0)
	_, err = col.GetAll()
	if err != nil {
		return nil, errors.New("getFiltered{{ firstCap $contentType.Sys.ID }}: " + err.Error())
	}
	all{{ firstCap $contentType.Sys.ID }}, err := colToCf{{ firstCap $contentType.Sys.ID }}(col,cc)
	if err != nil {
		return nil, errors.New("getFiltered{{ firstCap $contentType.Sys.ID }}: " + err.Error())
	}
	{{ $contentType.Sys.ID }}Map := map[string]*Cf{{ firstCap $contentType.Sys.ID }}{}
	for _, {{ $contentType.Sys.ID }} := range all{{ firstCap $contentType.Sys.ID }} {
		{{ $contentType.Sys.ID }}Map[{{ $contentType.Sys.ID }}.Sys.ID] = {{ $contentType.Sys.ID }}
	}
	return {{ $contentType.Sys.ID }}Map, nil
}

func (cc *ContentfulClient) Get{{ firstCap $contentType.Sys.ID }}ByTag(ctx context.Context, tagName string) (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc == nil || cc.Client == nil {
		return nil, errors.New("Get{{ firstCap $contentType.Sys.ID }}ByTag: No client available")
	}
	if !cc.cacheInit {
		return nil, errors.New("Get{{ firstCap $contentType.Sys.ID }}ByTag: only available with cache")
	}
	tags, err := cc.getAllTags(ctx, true)
	if err != nil {
		return nil, errors.New("Get{{ firstCap $contentType.Sys.ID }}ByTag could not get tags from cache: " + err.Error())
	}
	cc.cacheMutex.{{ $contentType.Sys.ID }}GcLock.RLock()
	defer cc.cacheMutex.{{ $contentType.Sys.ID }}GcLock.RUnlock()
	if _, tagExists := tags[tagName]; !tagExists {
		return nil, nil
	}
	tagID := tags[tagName]
	for _, vo := range cc.Cache.entryMaps.{{ $contentType.Sys.ID }} {
		for _, voTag := range vo.Metadata.Tags {
			if voTag.Sys.ID == tagID {
				vos = append(vos, vo)
			}
		}
	}
	return vos, nil
}

func (cc *ContentfulClient) Get{{ firstCap $contentType.Sys.ID }}ByID(ctx context.Context, id string, forceNoCache ...bool) (vo *Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc == nil || cc.Client == nil {
		return nil, errors.New("Get{{ firstCap $contentType.Sys.ID }}ByID: No client available")
	}
	if cc.cacheInit && (len(forceNoCache) == 0 || !forceNoCache[0]) {
		cc.cacheMutex.{{ $contentType.Sys.ID }}GcLock.RLock()
		defer cc.cacheMutex.{{ $contentType.Sys.ID }}GcLock.RUnlock()
		vo, ok := cc.Cache.entryMaps.{{ $contentType.Sys.ID }}[id]
		if ok {
			return vo, nil
		}
		return nil, fmt.Errorf("Get{{ firstCap $contentType.Sys.ID }}ByID: entry '%s' not found in cache", id)
	}
	col := cc.Client.Entries.List(ctx, cc.SpaceID)
	col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Include(0).Equal("sys.id",id)
	_, err = col.GetAll()
	if err != nil {
		return nil, err
	}
		if len(col.Items) == 0 {
		return nil, fmt.Errorf("Get{{ firstCap $contentType.Sys.ID }}ByID: %s Not found", id)
	}
	vos, err := colToCf{{ firstCap $contentType.Sys.ID }}(col,cc)
	if err != nil {
		return nil, fmt.Errorf("Get{{ firstCap $contentType.Sys.ID }}ByID: Error converting %s to VO: %w", id, err)
	}
	vo = vos[0]
	return
}

func NewCf{{ firstCap $contentType.Sys.ID }}(contentfulClient ...*ContentfulClient) (cf{{ firstCap $contentType.Sys.ID }} *Cf{{ firstCap $contentType.Sys.ID }}) {
	cf{{ firstCap $contentType.Sys.ID }} = &Cf{{ firstCap $contentType.Sys.ID }}{}
	if len(contentfulClient) != 0 && contentfulClient[0] != nil {
    	cf{{ firstCap $contentType.Sys.ID }}.CC = contentfulClient[0]
    }
    {{ range $fieldIndex, $field := $contentType.Fields }}
		cf{{ firstCap $contentType.Sys.ID }}.Fields.{{ firstCap $field.ID }} = map[string]{{ mapFieldType $contentType.Sys.ID $field }}{}
	{{ end }}
	cf{{ firstCap $contentType.Sys.ID }}.Sys.ContentType.Sys.ID = "{{ $contentType.Sys.ID }}"
	cf{{ firstCap $contentType.Sys.ID }}.Sys.ContentType.Sys.Type = FieldTypeLink
	cf{{ firstCap $contentType.Sys.ID }}.Sys.ContentType.Sys.LinkType = "ContentType"
	return
}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) GetParents(ctx context.Context, contentType ...string) (parents []EntryReference, err error) {
	if vo == nil {
		return nil, errors.New("GetParents: Value Object is nil")
	}
	if vo.CC == nil {
        return nil, errors.New("GetParents: Value Object has no Contentful Client set")
    }
	return commonGetParents(ctx, vo.CC, vo.Sys.ID, contentType)
}

func (vo *Cf{{ firstCap $contentType.Sys.ID }}) GetPublishingStatus() string {
	if vo == nil {
		return ""
	}
	if vo.Sys.PublishedVersion == 0 {
		return StatusDraft
	}
	if vo.Sys.Version-vo.Sys.PublishedVersion == 1 {
		return StatusPublished
	}
	return StatusChanged
}

// {{ firstCap $contentType.Sys.ID }} Field getters
{{ range $fieldIndex, $field := $contentType.Fields }}
{{ if fieldIsBasic $field }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) {{ firstCap $field.ID }}(locale ...Locale) {{ mapFieldType $contentType.Sys.ID $field }} {
	if vo == nil {
		return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
	}
    if vo.CC == nil {
        return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
    }
	vo.Fields.RWLock{{ firstCap $field.ID }}.RLock()
	defer vo.Fields.RWLock{{ firstCap $field.ID }}.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogError, ErrLocaleUnsupported)
			}
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
		}
	}
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogWarn, ErrNotSet)
			}
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogWarn, ErrNotSetNoFallback)
			}
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
		}
	}
	return vo.Fields.{{ firstCap $field.ID }}[string(loc)]
}
{{ end }}
{{ if fieldIsComplex $field }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) {{ firstCap $field.ID }}(locale ...Locale) *{{ mapFieldType $contentType.Sys.ID $field }} {
	if vo == nil {
		return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
	}
    if vo.CC == nil {
        return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
    }
	vo.Fields.RWLock{{ firstCap $field.ID }}.RLock()
	defer vo.Fields.RWLock{{ firstCap $field.ID }}.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogError, ErrLocaleUnsupported)
			}
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
		}
	}
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogWarn, ErrNotSet)
			}
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogWarn, ErrNotSetNoFallback)
			}
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
		}
	}
	{{ $field.ID }} := vo.Fields.{{ firstCap $field.ID }}[string(loc)]
	return &{{ $field.ID }}
}
{{ end }}
{{ if fieldIsMultipleReference $field }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) {{ firstCap $field.ID }}(ctx context.Context, locale ...Locale) []*EntryReference {
	if vo == nil {
		return nil
	}
	if vo.CC == nil {
	    return nil
	}
	vo.Fields.RWLock{{ firstCap $field.ID }}.RLock()
	defer vo.Fields.RWLock{{ firstCap $field.ID }}.RUnlock()
	{{ $field.ID }} := []*EntryReference{}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogError, ErrLocaleUnsupported)
			}
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
		}
	}
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug  {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogWarn, ErrNotSet)
			}
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug  {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogWarn, ErrNotSetNoFallback)
			}
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
		}
	}
	for _, eachLocalized{{ firstCap $field.ID }} := range vo.Fields.{{ firstCap $field.ID }}[string(loc)] {
		contentType, err := vo.CC.GetContentTypeOfID(ctx, eachLocalized{{ firstCap $field.ID }}.Sys.ID)
		if err != nil {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogError, ErrNoTypeOfRefEntry)
			}
			continue
		}
		switch contentType {
		{{ range $index , $contentType := $contentTypes }}
		case ContentType{{ firstCap $contentType.Sys.ID }}:
			referencedVO, err := vo.CC.Get{{ firstCap $contentType.Sys.ID }}ByID(ctx, eachLocalized{{ firstCap $field.ID }}.Sys.ID)
			if err != nil {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogError, err)
			}
			return nil
		}
		{{ $field.ID }} = append({{ $field.ID }},&EntryReference{ContentType: contentType, ID: eachLocalized{{ firstCap $field.ID }}.Sys.ID, VO: referencedVO, CC: vo.CC})
		{{ end }}
		}
	}
	return {{ $field.ID }}
}
{{ end }}
{{ if fieldIsReference $field }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) {{ firstCap $field.ID }}(ctx context.Context, locale ...Locale) *EntryReference {
	if vo == nil {
		return nil
	}
	if vo.CC == nil {
        return nil
    }
	vo.Fields.RWLock{{ firstCap $field.ID }}.RLock()
	defer vo.Fields.RWLock{{ firstCap $field.ID }}.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogError, ErrLocaleUnsupported)
			}
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
		}
	}
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogWarn, ErrNotSet)
			}
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogWarn, ErrNotSetNoFallback)
			}
			return {{ mapFieldTypeLiteral $contentType.Sys.ID $field }}
		}
	}
	localized{{ firstCap $field.ID }} := vo.Fields.{{ firstCap $field.ID }}[string(loc)]
	contentType, err := vo.CC.GetContentTypeOfID(ctx, localized{{ firstCap $field.ID }}.Sys.ID)
	if err != nil {
		if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
			vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogError, ErrNoTypeOfRefEntry)
		}
		return nil
	}
	switch contentType {
	{{ range $index , $contentType := $contentTypes }}
	case ContentType{{ firstCap $contentType.Sys.ID }}:
		referencedVO, err := vo.CC.Get{{ firstCap $contentType.Sys.ID }}ByID(ctx, localized{{ firstCap $field.ID }}.Sys.ID)
		if err != nil {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogError, err)
			}
			return nil
		}
		return &EntryReference{ContentType: contentType, ID: localized{{ firstCap $field.ID }}.Sys.ID, VO: referencedVO, CC: vo.CC}
	{{ end }}
	}
	return nil
}
{{ end }}
{{ if fieldIsMultipleAsset $field }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) {{ firstCap $field.ID }}(ctx context.Context, locale ...Locale) []*contentful.AssetNoLocale {
	if vo == nil {
		return nil
	}
	if vo.CC == nil {
        return nil
    }
	vo.Fields.RWLock{{ firstCap $field.ID }}.RLock()
	defer vo.Fields.RWLock{{ firstCap $field.ID }}.RUnlock()
	{{ $field.ID }} := []*contentful.AssetNoLocale{}
	loc := DefaultLocale
	reqLoc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		reqLoc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogError, ErrLocaleUnsupported)
			}
			return nil
		}
	}
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogWarn, ErrNotSet)
			}
			return nil
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogWarn, ErrNotSetNoFallback)
			}
			return nil
		}
	}
	for _, eachLocalized{{ firstCap $field.ID }} := range vo.Fields.{{ firstCap $field.ID }}[string(loc)] {
		asset, err := vo.CC.GetAssetByID(ctx, eachLocalized{{ firstCap $field.ID }}.Sys.ID)
		if err != nil {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogError, ErrNoTypeOfRefAsset)
			}
			continue
		}
		tempAsset := &contentful.AssetNoLocale{}
		tempAsset.Sys = asset.Sys
		tempAsset.Fields = &contentful.FileFieldsNoLocale{}
		if _, ok := asset.Fields.Title[string(reqLoc)]; ok {
			tempAsset.Fields.Title = asset.Fields.Title[string(reqLoc)]
		} else {
			tempAsset.Fields.Title = asset.Fields.Title[string(loc)]
		}
		if _, ok := asset.Fields.Description[string(reqLoc)]; ok {
			tempAsset.Fields.Description = asset.Fields.Description[string(reqLoc)]
		} else {
			tempAsset.Fields.Description = asset.Fields.Description[string(loc)]
		}
		if _, ok := asset.Fields.File[string(reqLoc)]; ok {
			tempAsset.Fields.File = asset.Fields.File[string(reqLoc)]
		} else {
			tempAsset.Fields.File = asset.Fields.File[string(loc)]
		}
		{{ $field.ID }} = append({{ $field.ID }}, tempAsset)
	}
	return {{ $field.ID }}
}
{{ end }}
{{ if fieldIsAsset $field }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) {{ firstCap $field.ID }}(ctx context.Context, locale ...Locale) *contentful.AssetNoLocale {
	if vo == nil {
		return nil
	}
	if vo.CC == nil {
        return nil
    }
	vo.Fields.RWLock{{ firstCap $field.ID }}.RLock()
	defer vo.Fields.RWLock{{ firstCap $field.ID }}.RUnlock()
	loc := DefaultLocale
	reqLoc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		reqLoc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogError, ErrLocaleUnsupported)
			}
			return nil
		}
	}
	if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogWarn, ErrNotSet)
			}
			return nil
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.{{ firstCap $field.ID }}[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogWarn, ErrNotSetNoFallback)
			}
			return nil
		}
	}
	localized{{ firstCap $field.ID }} := vo.Fields.{{ firstCap $field.ID }}[string(loc)]
	asset, err := vo.CC.GetAssetByID(ctx, localized{{ firstCap $field.ID }}.Sys.ID)
	if err != nil {
		if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
			vo.CC.logFn(map[string]interface{}{"content type":vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method":"{{ firstCap $field.ID }}()"}, LogError, ErrNoTypeOfRefAsset)
		}
		return nil
	}
	tempAsset := &contentful.AssetNoLocale{}
	tempAsset.Sys = asset.Sys
	tempAsset.Fields = &contentful.FileFieldsNoLocale{}
	if _, ok := asset.Fields.Title[string(reqLoc)]; ok {
		tempAsset.Fields.Title = asset.Fields.Title[string(reqLoc)]
	} else {
		tempAsset.Fields.Title = asset.Fields.Title[string(loc)]
	}
	if _, ok := asset.Fields.Description[string(reqLoc)]; ok {
		tempAsset.Fields.Description = asset.Fields.Description[string(reqLoc)]
	} else {
		tempAsset.Fields.Description = asset.Fields.Description[string(loc)]
	}
	if _, ok := asset.Fields.File[string(reqLoc)]; ok {
		tempAsset.Fields.File = asset.Fields.File[string(reqLoc)]
	} else {
		tempAsset.Fields.File = asset.Fields.File[string(loc)]
	}
	return tempAsset
}
{{ end }}
{{ end }}

func (vo *Cf{{ firstCap $contentType.Sys.ID }}) IsArchived(ctx context.Context) (bool, error) {
if vo == nil {
return false, errors.New("IsArchived: Value Object is nil")
}
if vo.CC == nil {
return false, errors.New("IsArchived: Value Object has nil Contentful client")
}
if vo.CC.clientMode != ClientModeCMA {
return false, errors.New("IsArchived: Only available in ClientModeCMA")
}
cfEntry := &contentful.Entry{}
tmp, errMarshal := json.Marshal(vo)
if errMarshal != nil {
return false, errors.New("Cf{{ firstCap $contentType.Sys.ID }} IsArchived: Can't marshal JSON from VO")
}
errUnmarshal := json.Unmarshal(tmp, &cfEntry)
if errUnmarshal != nil {
return false, errors.New("Cf{{ firstCap $contentType.Sys.ID }} IsArchived: Can't unmarshal JSON into CF entry")
}
return len(cfEntry.Sys.ArchivedAt) > 0, nil
}

// {{ firstCap $contentType.Sys.ID }} Field setters
{{ range $fieldIndex, $field := $contentType.Fields }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) Set{{ firstCap $field.ID }}({{ $field.ID }} {{ mapFieldType $contentType.Sys.ID $field }}, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("Set{{ firstCap $field.ID }}({{ $field.ID }}: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLock{{ firstCap $field.ID }}.Lock()
	defer vo.Fields.RWLock{{ firstCap $field.ID }}.Unlock()
	if vo.Fields.{{ firstCap $field.ID }} == nil {
		vo.Fields.{{ firstCap $field.ID }} = make(map[string]{{ mapFieldType $contentType.Sys.ID $field }})
	}
	vo.Fields.{{ firstCap $field.ID }}[string(loc)] = {{ $field.ID }}
	return
}
{{ end }}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) UpsertEntry(ctx context.Context) (err error) {
	if vo == nil {
		return errors.New("UpsertEntry: Value Object is nil")
	}
	if vo.CC == nil {
		return errors.New("UpsertEntry: Value Object has nil Contentful client")
	}
	if vo.CC.clientMode != ClientModeCMA {
		return errors.New("UpsertEntry: Only available in ClientModeCMA")
	}
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UpsertEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UpsertEntry: Can't unmarshal JSON into CF entry")
	}

	err = vo.CC.Client.Entries.Upsert(ctx, vo.CC.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} UpsertEntry: Operation failed: %w", err)
	}
	return
}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) PublishEntry(ctx context.Context) (err error) {
	if vo == nil {
		return errors.New("PublishEntry: Value Object is nil")
	}
	if vo.CC == nil {
		return errors.New("PublishEntry: Value Object has nil Contentful client")
	}
	if vo.CC.clientMode != ClientModeCMA {
		return errors.New("PublishEntry: Only available in ClientModeCMA")
	}
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} PublishEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} PublishEntry: Can't unmarshal JSON into CF entry")
	}
	err = vo.CC.Client.Entries.Publish(ctx, vo.CC.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} PublishEntry: publish operation failed: %w", err)
	}
	return
}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) UnpublishEntry(ctx context.Context) (err error) {
	if vo == nil {
		return errors.New("UnpublishEntry: Value Object is nil")
	}
	if vo.CC == nil {
		return errors.New("UnpublishEntry: Value Object has nil Contentful client")
	}
	if vo.CC.clientMode != ClientModeCMA {
		return errors.New("UnpublishEntry: Only available in ClientModeCMA")
	}
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UnpublishEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UnpublishEntry: Can't unmarshal JSON into CF entry")
	}
	err = vo.CC.Client.Entries.Unpublish(ctx, vo.CC.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} UnpublishEntry: unpublish operation failed: %w", err)
	}
	return
}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) UpdateEntry(ctx context.Context) (err error) {
	if vo == nil {
		return errors.New("UpdateEntry: Value Object is nil")
	}
	if vo.CC == nil {
		return errors.New("UpdateEntry: Value Object has nil Contentful client")
	}
	if vo.CC.clientMode != ClientModeCMA {
		return errors.New("UpdateEntry: Only available in ClientModeCMA")
	}
	publishingStatus := vo.GetPublishingStatus()
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UpdateEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UpdateEntry: Can't unmarshal JSON into CF entry")
	}

	err = vo.CC.Client.Entries.Upsert(ctx, vo.CC.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} UpdateEntry: upsert operation failed: %w", err)
	}
	tmp, errMarshal = json.Marshal(cfEntry)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UpdateEntry: Can't marshal JSON back from CF entry")
	}
	errUnmarshal = json.Unmarshal(tmp, &vo)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} UpdateEntry: Can't unmarshal JSON back into VO")
	}
	if publishingStatus == StatusPublished {
		vo.Sys.Version++
		err = vo.CC.Client.Entries.Publish(ctx, vo.CC.SpaceID, cfEntry)
		if err != nil {
			return fmt.Errorf("CfShopCategory UpdateEntry: publish operation failed: %w", err)
		}
	}
	return
}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) DeleteEntry(ctx context.Context) (err error) {
	if vo == nil {
		return errors.New("DeleteEntry: Value Object is nil")
	}
	if vo.CC == nil {
		return errors.New("DeleteEntry: Value Object has nil Contentful client")
	}
	if vo.CC.clientMode != ClientModeCMA {
		return errors.New("DeleteEntry: Only available in ClientModeCMA")
	}
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} DeleteEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("Cf{{ firstCap $contentType.Sys.ID }} DeleteEntry: Can't unmarshal JSON into CF entry")
	}
	if cfEntry.Sys.PublishedCounter > 0 {
		errUnpublish := vo.CC.Client.Entries.Unpublish(ctx, vo.CC.SpaceID, cfEntry)
		if errUnpublish != nil && !strings.Contains(errUnpublish.Error(), "Not published")  {
			return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} DeleteEntry: Unpublish entry failed: %w", errUnpublish)
		}
	}
	errDelete := vo.CC.Client.Entries.Delete(ctx, vo.CC.SpaceID, cfEntry.Sys.ID)
	if errDelete != nil {
		return fmt.Errorf("Cf{{ firstCap $contentType.Sys.ID }} DeleteEntry: Delete entry failed: %w", errDelete)
	}
	return nil
}
func (vo *Cf{{ firstCap $contentType.Sys.ID }}) ToReference() (refSys ContentTypeSys) {
	if vo == nil {
		return refSys
	}
	refSys.Sys.ID = vo.Sys.ID
	refSys.Sys.Type = FieldTypeLink
	refSys.Sys.LinkType = FieldLinkTypeEntry
	return
}

func (cc *ContentfulClient) cacheAll{{ firstCap $contentType.Sys.ID }}(ctx context.Context, resultChan chan<- ContentTypeResult) (vos map[string]*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	if cc == nil || cc.Client == nil {
		return nil, errors.New("cacheAll{{ firstCap $contentType.Sys.ID }}: No CDA/CPA client available")
	}
	var all{{ firstCap $contentType.Sys.ID }} []*Cf{{ firstCap $contentType.Sys.ID }}
	col := &contentful.Collection{
		Items: []interface{}{},
	}
	cc.cacheMutex.sharedDataGcLock.RLock()
	defer cc.cacheMutex.sharedDataGcLock.RUnlock()
	if cc.offline {
		for _, entry := range cc.offlineTemp.Entries {
			if entry.Sys.ContentType.Sys.ID == ContentType{{ firstCap $contentType.Sys.ID }} {
				col.Items = append(col.Items, entry)
			}
		}
	} else {
		col, err = cc.optimisticPageSizeGetAll(ctx, "{{ $contentType.Sys.ID }}", cc.optimisticPageSize)
		if err != nil {
			return nil, errors.New("optimisticPageSizeGetAll for {{ firstCap $contentType.Sys.ID }} failed: "+err.Error())
		}
	}
	all{{ firstCap $contentType.Sys.ID }}, err = colToCf{{ firstCap $contentType.Sys.ID }}(col,cc)
	if err != nil {
		return nil, errors.New("colToCf{{ firstCap $contentType.Sys.ID }} failed: "+err.Error())
	}
	{{ $contentType.Sys.ID }}Map := map[string]*Cf{{ firstCap $contentType.Sys.ID }}{}
	for _, {{ $contentType.Sys.ID }} := range all{{ firstCap $contentType.Sys.ID }} {
		if cc.cacheInit {
            existing{{ firstCap $contentType.Sys.ID }}, err := cc.Get{{ firstCap $contentType.Sys.ID }}ByID(ctx, {{ $contentType.Sys.ID }}.Sys.ID)
            if err == nil && existing{{ firstCap $contentType.Sys.ID }} != nil && existing{{ firstCap $contentType.Sys.ID }}.Sys.Version > {{ $contentType.Sys.ID }}.Sys.Version {
                return nil, fmt.Errorf("cache update canceled because {{ firstCap $contentType.Sys.ID }} entry %s is newer in cache", {{ $contentType.Sys.ID }}.Sys.ID)
            }
        }
		{{ $contentType.Sys.ID }}Map[{{ $contentType.Sys.ID }}.Sys.ID] = {{ $contentType.Sys.ID }}
	result := ContentTypeResult{
	EntryID: {{ $contentType.Sys.ID }}.Sys.ID,
	ContentType: ContentType{{ firstCap $contentType.Sys.ID }},
	References:  map[string][]EntryReference{},
	}
	addEntry := func(id string, refs EntryReference){
		if result.References[id] == nil {
			result.References[id] = []EntryReference{}
		}
		result.References[id] = append(result.References[id], refs)
	}
	_ = addEntry
	{{ range $fieldIndex, $field := $contentType.Fields }}
	{{ if fieldIsMultipleReference $field }}
		for _, loc := range cc.locales {
		children, okChildren := {{ $contentType.Sys.ID }}.Fields.{{ firstCap $field.ID }}[string(loc)]
		if okChildren {
			for _, child := range children {
				addEntry(child.Sys.ID, EntryReference{ContentType: {{ $contentType.Sys.ID }}.Sys.ContentType.Sys.ID,
					ID: {{ $contentType.Sys.ID }}.Sys.ID,
					VO: {{ $contentType.Sys.ID }},
					CC: cc,
					FromField: "{{ $field.ID }}",
				})
			}
		}
	}
	{{ end }}
	{{ if fieldIsReference $field }}
	for _, loc := range cc.locales {
		child, okChild := {{ $contentType.Sys.ID }}.Fields.{{ firstCap $field.ID }}[string(loc)]
		if okChild {
			addEntry(child.Sys.ID, EntryReference{ContentType: {{ $contentType.Sys.ID }}.Sys.ContentType.Sys.ID,
				ID: {{ $contentType.Sys.ID }}.Sys.ID,
				VO: {{ $contentType.Sys.ID }},
				CC: cc,
				FromField: "{{ $field.ID }}",
})
		}
	}
	{{ end }}
	{{ end }}
		if ctx.Err() != nil {
			return nil, ctx.Err()
		}
		resultChan <- result
	}
	return {{ $contentType.Sys.ID }}Map, nil
}

func (cc *ContentfulClient) cache{{ firstCap $contentType.Sys.ID }}ByID(ctx context.Context, id string, entryPayload *contentful.Entry, entryDelete bool) error {
	cc.cacheMutex.{{ $contentType.Sys.ID }}GcLock.Lock()
	defer cc.cacheMutex.{{ $contentType.Sys.ID }}GcLock.Unlock()
	cc.cacheMutex.idContentTypeMapGcLock.Lock()
	defer cc.cacheMutex.idContentTypeMapGcLock.Unlock()
	cc.cacheMutex.parentMapGcLock.Lock()
	defer cc.cacheMutex.parentMapGcLock.Unlock()
	cc.cacheMutex.genericEntriesGcLock.Lock()
	defer cc.cacheMutex.genericEntriesGcLock.Unlock()
	var col *contentful.Collection
	if entryPayload != nil {
		col = &contentful.Collection{
			Items: []interface{}{entryPayload},
		}
		id = entryPayload.Sys.ID
	} else {
		if cc.Client == nil {
			return errors.New("cache{{ firstCap $contentType.Sys.ID }}ByID: No client available")
		}
		if !entryDelete {
			col = cc.Client.Entries.List(ctx, cc.SpaceID)
			col.Query.ContentType("{{ $contentType.Sys.ID }}").Locale("*").Include(0).Equal("sys.id", id)
			_, err := col.GetAll()
			if err != nil {
				return err
			}
		}
	}
	// It was deleted
	if col != nil && len(col.Items) == 0 || entryDelete {
		delete(cc.Cache.genericEntries, id)
		delete(cc.Cache.entryMaps.{{ $contentType.Sys.ID }}, id)
		delete(cc.Cache.idContentTypeMap, id)
		// delete as child
		delete(cc.Cache.parentMap, id)
		// delete as parent
		for childID, parents := range cc.Cache.parentMap {
			newParents := []EntryReference{}
			for _, parent := range parents {
				if parent.ID != id {
					newParents = append(newParents, parent)
				}
			}
			cc.Cache.parentMap[childID] = newParents
		}
		return nil
	}
	vos, err := colToCf{{ firstCap $contentType.Sys.ID }}(col, cc)
	if err != nil {
		return fmt.Errorf("cache{{ firstCap $contentType.Sys.ID }}ByID: Error converting %s to VO: %w", id, err)
	}
	{{ $contentType.Sys.ID }} := vos[0]
	if cc.Cache.entryMaps.{{ $contentType.Sys.ID }} == nil {
		cc.Cache.entryMaps.{{ $contentType.Sys.ID }} = map[string]*Cf{{ firstCap $contentType.Sys.ID }}{}
	}
	cc.Cache.entryMaps.{{ $contentType.Sys.ID }}[id] = {{ $contentType.Sys.ID }}
	cc.Cache.genericEntries[id] = &GenericEntry{
				Sys:       {{ $contentType.Sys.ID }}.Sys,
				RawFields: {{ $contentType.Sys.ID }}.RawFields,
				CC:        {{ $contentType.Sys.ID }}.CC,
	}
	cc.Cache.idContentTypeMap[id] = {{ $contentType.Sys.ID }}.Sys.ContentType.Sys.ID
	allChildrensIds := map[string]bool{}
	{{ range $fieldIndex, $field := $contentType.Fields }}
	{{ if fieldIsMultipleReference $field }}
	for _, loc := range cc.locales {
		children, okChildren := {{ $contentType.Sys.ID }}.Fields.{{ firstCap $field.ID }}[string(loc)]
		if okChildren {
			for _, child := range children {
				allChildrensIds[child.Sys.ID] = true
				if cc.Cache.parentMap[child.Sys.ID] == nil {
					cc.Cache.parentMap[child.Sys.ID] = []EntryReference{}
				}
				newParentRef := EntryReference{ContentType: {{ $contentType.Sys.ID }}.Sys.ContentType.Sys.ID, ID: {{ $contentType.Sys.ID }}.Sys.ID, VO: {{ $contentType.Sys.ID }}, CC: cc, FromField: "{{ $field.ID }}" }
				newParentSlice := []EntryReference{}
				for _, parent := range cc.Cache.parentMap[child.Sys.ID] {
					if parent.ID != id {
						newParentSlice = append(newParentSlice, parent)
					}
				}
				newParentSlice = append(newParentSlice, newParentRef)
				cc.Cache.parentMap[child.Sys.ID] = newParentSlice
			}
		}
	}
	{{ end }}
	{{ if fieldIsReference $field }}
		for _, loc := range cc.locales {
			child, okChild := {{ $contentType.Sys.ID }}.Fields.{{ firstCap $field.ID }}[string(loc)]
			if okChild {
				allChildrensIds[child.Sys.ID] = true
				if cc.Cache.parentMap[child.Sys.ID] == nil {
					cc.Cache.parentMap[child.Sys.ID] = []EntryReference{}
				}
				newParentRef := EntryReference{ContentType: {{ $contentType.Sys.ID }}.Sys.ContentType.Sys.ID, ID: {{ $contentType.Sys.ID }}.Sys.ID, VO: {{ $contentType.Sys.ID }}, CC: cc, FromField: "{{ $field.ID }}" }
				newParentSlice := []EntryReference{}
				for _, parent := range cc.Cache.parentMap[child.Sys.ID] {
					if parent.ID != id {
						newParentSlice = append(newParentSlice, parent)
					}
				}
				newParentSlice = append(newParentSlice, newParentRef)
				cc.Cache.parentMap[child.Sys.ID] = newParentSlice
			}
		}
	{{ end }}
	{{ end }}
	_ = allChildrensIds // safety net
	// clean up child-parents that don't exist anymore
	for childID, parents := range cc.Cache.parentMap {
		if _, isCollectedChildID := allChildrensIds[childID]; isCollectedChildID {
			continue
		}
		newParents := []EntryReference{}
		for _, parent := range parents {
			if parent.ID != id {
				newParents = append(newParents, parent)
			}
		}
		cc.Cache.parentMap[childID] = newParents
	}
	return nil
}

func colToCf{{ firstCap $contentType.Sys.ID }}(col *contentful.Collection, cc *ContentfulClient) (vos []*Cf{{ firstCap $contentType.Sys.ID }}, err error) {
	for _, item := range col.Items {
		var vo Cf{{ firstCap $contentType.Sys.ID }}
		byteArray, _ := json.Marshal(item)
		err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&vo)
		if err != nil {
			break
		}
		if cc.textJanitor {
			{{ range $fieldIndex, $field := $contentType.Fields }}
			{{ if or (fieldIsSymbol $field) (fieldIsText $field) }}
			vo.Fields.{{ firstCap $field.ID }} = cleanUpStringField(vo.Fields.{{ firstCap $field.ID }}){{ end }}
			{{ if fieldIsSymbolList $field }}
			vo.Fields.{{ firstCap $field.ID }} = cleanUpStringSliceField(vo.Fields.{{ firstCap $field.ID }}){{ end }}
			{{ if fieldIsRichText $field }}
			vo.Fields.{{ firstCap $field.ID }} = cleanUpRichTextField(vo.Fields.{{ firstCap $field.ID }}){{ end }}
			{{ end }}
		}
		var typedItem RawItem
		err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&typedItem)
		if err != nil {
			break
		}
		vo.CC = cc
		vo.RawFields = typedItem.Fields
		vos = append(vos, &vo)
	}
	return vos, err
}

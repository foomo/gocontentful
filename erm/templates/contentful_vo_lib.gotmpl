// Code generated by https://github.com/foomo/gocontentful {{ .Version }} - DO NOT EDIT.
{{ $cfg := . }}{{ $contentTypes := .ContentTypes }}{{ $locales := .Locales }}package {{ .PackageName }}

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"html"
	"io"
	"os"
	"regexp"
	"strings"
	"sync"
	"time"
	"unicode"
	"github.com/foomo/contentful"
	"golang.org/x/sync/errgroup"
)

type cacheEntryMaps struct {
	{{ range $index , $contentType := $contentTypes }}	{{ $contentType.Sys.ID }} map[string]*Cf{{ firstCap $contentType.Sys.ID }}
	{{ end }}
}

type ClientMode string

type ContentfulCache struct {
	assets                 assetCacheMap
	contentTypes           []string
	entryMaps              cacheEntryMaps
	idContentTypeMap       map[string]string
	parentMap              map[string][]EntryReference
}

type ContentfulCacheMutex struct {
	fullCacheGcLock        sync.RWMutex
	sharedDataGcLock       sync.RWMutex
	assetsGcLock           sync.RWMutex
	idContentTypeMapGcLock sync.RWMutex
	parentMapGcLock        sync.RWMutex
	{{ range $index , $contentType := $contentTypes }}	{{ $contentType.Sys.ID }}GcLock sync.RWMutex
    {{ end }}
}

type assetCacheMap map[string]*contentful.Asset

type ContentfulClient struct {
	Cache              *ContentfulCache
    cacheInit          bool
	cacheMutex         *ContentfulCacheMutex
	cacheQueue         chan struct{}
	cacheDone          chan struct{}
	cacheUpdateTimeout int64
	cacheWorkerOnce    sync.Once
	clientMode         ClientMode
	Client             *contentful.Contentful
	locales            []Locale
	logFn              func(
		fields map[string]interface{},
		level int,
		args ...interface{},
	)
	logLevel           int
	optimisticPageSize uint16
	SpaceID            string
	offline            bool
	offlineTemp        offlineTemp
	sync 			   bool
	syncToken          string
	textJanitor        bool
}

type offlineTemp struct {
	Entries []contentful.Entry `json:"entries"`
	Assets  []contentful.Asset `json:"assets"`
}

type ContentTypeResult struct {
	EntryID     string
	ContentType string
	References  map[string][]EntryReference
}

type ContentTypeInfo struct {
	ContentType string
	Title       string
	Description string
}

type ContentTypeInfoMap map[string]ContentTypeInfo

type EntryReference struct {
	ContentType string
	ID string
	VO interface{}
	FromField   string
}

type BrokenReference struct {
	ParentID   string `json:"parentId"`
	ParentType string `json:"parentType"`
	FromField  string `json:"fromField"`
	ChildID    string `json:"childId"`
}


type ImageResolverFunc func(assetID string, locale Locale) (attrs map[string]string, customHTML string, resolveError error)
type EntryLinkResolverFunc func(entryID string, locale Locale) (resolvedAttrs map[string]string, resolveError error)
type LinkResolverFunc func(url string) (resolvedAttrs map[string]string, resolveError error)
type EmbeddedEntryResolverFunc func(entryID string, locale Locale) (htmlSnippet string, resolveError error)

type Locale string

const (
	ClientModeCDA ClientMode = "CDA"
	ClientModeCPA ClientMode = "CPA"
	ClientModeCMA ClientMode = "CMA"
)

const (
	LogDebug = 0
	LogInfo = 1
	LogWarn = 2
	LogError = 3
)

{{ range $index , $locale := $locales }}const SpaceLocale{{ onlyLetters $locale.Name }} Locale = "{{ $locale.Code }}"
{{ end }}
var SpaceLocales = []Locale{ {{ range $index , $locale := $locales }}
"{{$locale.Code}}",{{ end }}
}
{{ range $index , $locale := $locales }}{{ if $locale.Default }}const defaultLocale Locale = SpaceLocale{{ onlyLetters $locale.Name }}{{ end }}
{{ end }}var localeFallback = map[Locale]Locale{ {{ range $index, $locale := $locales }}{{if $locale.FallbackCode}} SpaceLocale{{ onlyLetters $locale.Name }}: {{ range $indexSearch, $localeSearch := $locales }}{{ if eq $localeSearch.Code $locale.FallbackCode}}SpaceLocale{{ onlyLetters $localeSearch.Name }}{{ end }}{{ end }}, {{ else }}SpaceLocale{{ onlyLetters $locale.Name }}: "", {{ end }}{{ end }}}

const (
	assetPageSize = 1000
	assetWorkerType = "_asset"
)

const cacheUpdateConcurrency = 4

const (
	sysTypeEntry = "Entry"
	sysTypeAsset = "Asset"
	sysTypeDeletedEntry = "DeletedEntry"
	sysTypeDeletedAsset = "DeletedAsset"
)

var (
	ErrLocaleUnsupported             = errors.New("locale not supported by this space")
	ErrNotSet                        = errors.New("field value not set")
	ErrNotSetNoFallback              = errors.New("field value not set and no fallback locale available")
	ErrRefNotIncludes                = errors.New("referenced entry not found in includes")
	ErrNoTypeOfRefEntry              = errors.New("couldn't get contentType of referenced entry")
	ErrNoTypeOfRefAsset              = errors.New("couldn't get contentType of referenced asset")
	InfoUpdatedEntityCache           = "updated cache for entity"
	InfoCachedAllEntries             = "cached all entries of content type"
	InfoCachedAllAssets              = "cached all assets"
	InfoFallingBackToFile            = "gonna use a local file"
	InfoLoadingFromFile              = "loading space from local file"
	InfoCacheWorkerStart             = "contentful cache worker starting"
	InfoCacheUpdateQueued            = "contentful cache update queued"
	InfoCacheUpdateCanceled          = "contentful cache update canceled"
	InfoCacheUpdateDone              = "contentful cache update returning"
	InfoCacheUpdateSkipped           = "contentful cache update skipped, already one in the queue"
	InfoOfflineEntitiesLoaded        = "downloaded entries and assets from offline file"
	InfoPreservingExistingCache      = "could not connect for cache update, preserving the existing cache"
	InfoUpdateCacheTime              = "space caching done, time recorded"
	ErrorEnvironmentSetToMaster      = "environment was empty string, set to master"
	ErrorEntryIsNil 			     = "entry is nil"
	ErrorEntrySysIsNil 			     = "entry.Sys is nil"
	ErrorEntrySysContentTypeIsNil    = "entry.Sys.ContentType is nil"
	ErrorEntrySysContentTypeSysIsNil = "entry.Sys.ContentType.Sys is nil"
)

var spaceContentTypes = []string{ {{ range $index , $contentType := $contentTypes }}ContentType{{ firstCap $contentType.Sys.ID }}, {{ end }} }
var SpaceContentTypeInfoMap = ContentTypeInfoMap{ {{ range $index , $contentType := $contentTypes }}
    "{{ $contentType.Sys.ID }}": ContentTypeInfo{
            ContentType: "{{ $contentType.Sys.ID }}",
            Title:       "{{ $contentType.Name }}",
            Description: "{{ $contentType.Description }}",
        },{{ end }}
}
func (cc *ContentfulClient) BrokenReferences() (brokenReferences []BrokenReference) {
    if cc.Cache == nil || cc.cacheMutex == nil {
        return
    }
    cc.cacheMutex.parentMapGcLock.Lock()
    defer cc.cacheMutex.parentMapGcLock.Unlock()
    cc.cacheMutex.idContentTypeMapGcLock.Lock()
    defer cc.cacheMutex.idContentTypeMapGcLock.Unlock()
    for childID, parents := range cc.Cache.parentMap {
		if _, okGotEntry := cc.Cache.idContentTypeMap[childID]; !okGotEntry {
			for _, parent := range parents {
				brokenReferences = append(brokenReferences, BrokenReference{
					ParentID:   parent.ID,
					ParentType: parent.ContentType,
					FromField:  parent.FromField,
					ChildID:    childID,
				})
			}
		}
	}
	return
}

func (cc *ContentfulClient) CacheHasContentType(contentTypeID string) bool {
	if cc.Cache == nil {
		return false
	}
	for _, cachedContentType := range cc.Cache.contentTypes {
		if cachedContentType == contentTypeID {
			return true
		}
	}
	return false
}

func (cc *ContentfulClient) ClientStats() {
	if cc == nil {
		cc.logFn(nil, LogWarn, "ClientStats: no client available")
		return
	}
	if cc.logFn != nil {
		fieldsMap := map[string]interface{}{
			"space ID":     cc.SpaceID,
			"environment":  cc.Client.Environment,
			"clientMode":   cc.clientMode,
			"contentTypes": strings.Join(cc.Cache.contentTypes, ","),
			"locales":      cc.locales,
			"cached":       cc.cacheInit,
		}
		if cc.cacheInit {
			fieldsMap["cache asset count"] = len(cc.Cache.assets)
			fieldsMap["cache entry count"] = len(cc.Cache.idContentTypeMap)
			fieldsMap["cache parentMap length"] = len(cc.Cache.parentMap)
		}
		cc.logFn(fieldsMap, LogInfo, "Contentful ClientStats")
	}
}

func (ref ContentfulReferencedEntry) ContentType() (contentType string) {
	return ref.Entry.Sys.ContentType.Sys.ID
}

func (cc *ContentfulClient) DeleteAsset(asset *contentful.Asset) error {
	if cc == nil || cc.Client == nil {
		return errors.New("DeleteAsset: No client available")
	}
	if cc.clientMode != ClientModeCMA {
		return errors.New("DeleteAsset: Only available in ClientModeCMA")
	}
	errUnpublish := cc.Client.Assets.Unpublish(cc.SpaceID, asset)
	if errUnpublish != nil && !strings.Contains(errUnpublish.Error(), "Not published") {
		return errUnpublish
	}
	errDelete := cc.Client.Assets.Delete(cc.SpaceID, asset)
	if errDelete != nil {
		return errDelete
	}
	return nil
}

func (cc *ContentfulClient) DeleteAssetFromCache(key string) error {
	return cc.deleteAssetFromCache(key)
}

func (cc *ContentfulClient) DisableTextJanitor() {
	cc.textJanitor = false
}

func (cc *ContentfulClient) EnableTextJanitor() {
	cc.textJanitor = true
}

func (cc *ContentfulClient) GetAllAssets() (map[string]*contentful.Asset, error) {
	return cc.getAllAssets(true)
}

func (cc *ContentfulClient) GetAssetByID(id string, forceNoCache ...bool) (*contentful.Asset, error) {
	if cc == nil || cc.Client == nil {
		return nil, errors.New("GetAssetByID: No client available")
	}
	if cc.cacheInit && cc.Cache.assets != nil && (len(forceNoCache) == 0 || !forceNoCache[0]) {
		cc.cacheMutex.assetsGcLock.Lock()
		asset, okAsset := cc.Cache.assets[id]
		cc.cacheMutex.assetsGcLock.Unlock()
		if okAsset {
			return asset, nil
		} else {
			return nil, errors.New("GetAssetByID: not found")
		}
	}
	col := cc.Client.Assets.List(cc.SpaceID)
	col.Query.Locale("*").Equal("sys.id",id)
	_, err := col.Next()
	if err != nil {
		return nil, err
	}
	if len(col.Items) == 0 {
		return nil, errors.New("GetAssetByID: Not found "+ id)
	}
	item := col.Items[0]
	asset := contentful.Asset{}
	byt, err := json.Marshal(item)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(byt, &asset)
	if err != nil {
		return nil, err
	}
	for _, loc := range []Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }},{{end}} } {
		if _, ok := asset.Fields.File[string(loc)]; ok {
			asset.Fields.File[string(loc)].URL = "https:" + asset.Fields.File[string(loc)].URL
		}
	}
	return &asset, nil
}

func (cc *ContentfulClient) GetContentTypeOfID(id string) (string, error) {
	if cc == nil || cc.Client == nil {
		return "", errors.New("GetContentTypeOfID: No client available")
	}
	if cc.cacheInit {
		okVo := false
		{{ range $index , $contentType := $contentTypes }}
		cc.cacheMutex.{{ $contentType.Sys.ID }}GcLock.Lock()
		_, okVo = cc.Cache.entryMaps.{{ $contentType.Sys.ID }}[id]
		cc.cacheMutex.{{ $contentType.Sys.ID }}GcLock.Unlock()
		if okVo {
			return ContentType{{ firstCap $contentType.Sys.ID }}, nil
		}
		{{ end }}
		return "", fmt.Errorf("GetContentTypeOfID: %s Not found in cache", id)
	}
	col := cc.Client.Entries.List(cc.SpaceID)
	col.Query.Include(0).Equal("sys.id",id)
	_, err := col.GetAll()
	if err != nil {
		return "", errors.New("GetContentTypeOfID: "+err.Error())
	}
	if len(col.Items) == 0 {
		return "", fmt.Errorf("GetContentTypeOfID: %s Not found online", id)
	}
	var vo genericEntryNoFields
	byteArray, _ := json.Marshal(col.Items[0])
	err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&vo)
	if err != nil {
		return "", errors.New("GetContentTypeOfID: "+err.Error())
	}
	return vo.Sys.ContentType.Sys.ID, nil
}

func (ref *EntryReference) GetParents(cc *ContentfulClient) (parents []EntryReference, err error) {
	if ref == nil {
		return nil, errors.New("GetParents: reference is nil")
	}
	if cc == nil {
		return nil, errors.New("GetParents: Contentful client is nil")
	}
	if cc.Cache == nil {
		return nil, errors.New("GetParents: only available in cached mode")
	}
	return cc.Cache.parentMap[ref.ID], nil
}

func HtmlToRichText(htmlSrc string) *RichTextNode {
	htmlClean := strings.TrimSpace(htmlSrc)
	htmlClean = strings.ReplaceAll(htmlClean, `&nbsp;`, ` `)
	htmlClean = strings.ReplaceAll(htmlClean, "&amp;", "&")
    htmlClean = strings.ReplaceAll(htmlClean, "\t", "")
	htmlClean = regexp.MustCompile(`[\s]{2,}`).ReplaceAllString(htmlClean, " ")
	re := regexp.MustCompile(`>([^\n])`)
	htmlClean = re.ReplaceAllString(htmlClean, fmt.Sprintf(">\n"+`$1`))
	re = regexp.MustCompile(`(.{1})<`)
	htmlClean = re.ReplaceAllString(htmlClean, `$1`+"\n<")
	htmlLines := strings.Split(htmlClean, "\n")
	rtnd := &RichTextNode{
		NodeType: RichTextNodeDocument,
	}
	var isBasic bool
	rtnd.Content, _, isBasic = richTextHtmlLinesToNode(htmlLines, 0, "", nil, true)
	if isBasic {
        basicRich := &RichTextNode{
            NodeType: RichTextNodeDocument,
            Content:  rtnd.Content,
        }
        return basicRich
    }
	return rtnd
}

func NewAssetFromURL(id string, uploadUrl string, imageFileType string, title string, locale ...Locale) *contentful.Asset {
	autoID := fmt.Sprintf("%d", time.Now().UnixNano()/int64(time.Millisecond))
	if id == "" {
		id = autoID
	}
	if title == "" {
		title = id
	}
	var loc Locale
	if len(locale) != 0 {
		loc = locale[0]
		if localeFallback[loc]!="" {
			return nil
		}
	} else {
		loc = defaultLocale
	}
	asset := &contentful.Asset{
		Sys: &contentful.Sys{
			ID: id,
		},
		Fields: &contentful.FileFields{
			File: map[string]*contentful.File{
				string(loc): {
					UploadURL:   uploadUrl,
					ContentType: imageFileType,
					Name:        id,
				},
			},
			Title: map[string]string{
				string(loc): title,
			},
		},
	}
	return asset
}

func NewContentfulClient(spaceID string, clientMode ClientMode, clientKey string, optimisticPageSize uint16, logFn func(fields map[string]interface{}, level int, args ...interface{}), logLevel int, debug bool) (*ContentfulClient, error) {
	if spaceID == "" {
		return nil, errors.New("NewContentfulClient: SpaceID cannot be empty")
	}
	if clientMode != ClientModeCMA && clientMode != ClientModeCPA && clientMode != ClientModeCDA {
		return nil, errors.New("NewContentfulClient: clientMode not supported")
	}
	if optimisticPageSize < 10 {
		return nil, errors.New("NewContentfulClient: optimisticPageSize must be 10 or bigger")
	}
	if logLevel < 0 || logLevel > 3 {
		return nil, errors.New("NewContentfulClient: logLevel must be between 0 and 3")
	}
	if clientKey == "" {
		return nil, errors.New("NewContentfulClient: Please provide an API key")
	}
	apiClient, err := getContentfulAPIClient(clientMode, clientKey)
	if err != nil {
		return nil, err
	}
	apiClient.Debug = debug
	cc := &ContentfulClient{
		clientMode:         clientMode,
		Client:             apiClient,
		Cache: &ContentfulCache{
			assets:           assetCacheMap{},
			contentTypes :    []string{},
			entryMaps:        cacheEntryMaps{},
			idContentTypeMap: map[string]string{},
			parentMap:        map[string][]EntryReference{},
		},
        cacheMutex: &ContentfulCacheMutex{
            fullCacheGcLock:        sync.RWMutex{},
            sharedDataGcLock:       sync.RWMutex{},
            assetsGcLock:           sync.RWMutex{},
            idContentTypeMapGcLock: sync.RWMutex{},
            parentMapGcLock:        sync.RWMutex{},
            {{ range $index , $contentType := $contentTypes }}	{{ $contentType.Sys.ID }}GcLock: sync.RWMutex{},
            {{ end }}
        },
        cacheQueue:         make(chan struct{}, 1),
        cacheDone:          make(chan struct{}, 1),
        cacheUpdateTimeout: 120,
		locales:			[]Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }}, {{ end }} },
		logFn:              logFn,
		logLevel:           logLevel,
		optimisticPageSize: optimisticPageSize,
		SpaceID:            spaceID,
		sync:               clientMode == ClientModeCDA,
	}
	_, err = cc.Client.Spaces.Get(spaceID)
	if err != nil {
		_, ok := err.(contentful.NotFoundError)
		if ok {
			return nil, errors.New("NewContentfulClient: That is not the space you're looking for")
		}
		return nil, errors.New("NewContentfulClient: "+err.Error())
	}
	return cc, nil
}

func NewOfflineContentfulClient(filename string, logFn func(fields map[string]interface{}, level int, args ...interface{}), logLevel int, cacheAssets bool, textJanitor bool) (*ContentfulClient, error) {
	offlineTemp, err := getOfflineSpaceFromFile(filename)
	if err != nil {
		return nil, fmt.Errorf("NewOfflineContentfulClient could not parse space export file: %v", err)
	}
	cc := &ContentfulClient{
		clientMode:  ClientModeCDA,
		Client:      contentful.NewCDA(""),
		Cache: &ContentfulCache{
            contentTypes:     []string{},
            idContentTypeMap: map[string]string{},
            parentMap:        map[string][]EntryReference{},
            },
        cacheMutex: &ContentfulCacheMutex{
            fullCacheGcLock:        sync.RWMutex{},
            sharedDataGcLock:       sync.RWMutex{},
            assetsGcLock:           sync.RWMutex{},
            idContentTypeMapGcLock: sync.RWMutex{},
            parentMapGcLock:        sync.RWMutex{},
            {{ range $index , $contentType := $contentTypes }}	{{ $contentType.Sys.ID }}GcLock: sync.RWMutex{},
            {{ end }}
        },
		cacheQueue: make(chan struct{}, 1),
		cacheDone: make(chan struct{}, 1),
		cacheUpdateTimeout: 120,
		locales:     []Locale{
			{{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }},
{{ end}}},
		logFn:       logFn,
		logLevel:    logLevel,
		SpaceID:     "OFFLINE",
		offline:     true,
		offlineTemp: *offlineTemp,
		textJanitor: textJanitor,
	}
	if cc.logFn != nil && cc.logLevel <= LogInfo {
        cc.logFn(map[string]interface{}{"entries": len(offlineTemp.Entries),"assets": len(offlineTemp.Assets)}, LogInfo, InfoLoadingFromFile)
    }
	err = cc.UpdateCache(context.TODO(), spaceContentTypes, cacheAssets)
	if err != nil {
		return nil, fmt.Errorf("NewOfflineContentfulClient could not cache offline space: %v", err)
	}
	return cc, nil
}

func RichTextToHtml(rt interface{}, linkResolver LinkResolverFunc, entryLinkResolver EntryLinkResolverFunc, imageResolver ImageResolverFunc, embeddedEntryResolver EmbeddedEntryResolverFunc, locale Locale) (string, error) {
	w := bytes.NewBuffer([]byte{})
	node := &RichTextGenericNode{}
	byt, err := json.Marshal(rt)
	if err != nil {
		return "", err
	}
	err = json.Unmarshal(byt, node)
	if err != nil {
		return "", err
	}
	err = node.richTextRenderHTML(w, linkResolver, entryLinkResolver, imageResolver, embeddedEntryResolver, locale)
	if err != nil {
		return "", err
	}
	out := w.String()
	if out == "<p></p>" {
		return "", nil
	}
	return out, nil
}

func (cc *ContentfulClient) SetCacheUpdateTimeout(seconds int64) {
	cc.cacheUpdateTimeout = seconds
}

func (cc *ContentfulClient) SetEnvironment(environment string) {
	if environment == "" {
		cc.Client.Environment = "master"
		if cc.logFn != nil && cc.logLevel <= LogWarn {
			cc.logFn(map[string]interface{}{"task":"UpdateCache"}, LogWarn, ErrorEnvironmentSetToMaster)
		}
		return
	}
	cc.Client.Environment = environment
}

func (cc *ContentfulClient) SetOfflineFallback(filename string) error {
	offlineTemp, err := getOfflineSpaceFromFile(filename)
	if err != nil {
		return err
	}
	cc.offlineTemp = *offlineTemp
	return nil
}

func (cc *ContentfulClient) SetSyncMode(mode bool) error {
	if cc.offline {
		return errors.New("SetSyncMode: client is set offline, can't enable sync")
	}
	cc.sync = mode
	return nil
}

func (cc *ContentfulClient) ResetSync() {
	cc.syncToken = ""
}

func (cc *ContentfulClient) UpdateCache(ctx context.Context, contentTypes []string, cacheAssets bool) error {
    ctxAtWork, cancel := context.WithTimeout(ctx, time.Second*time.Duration(cc.cacheUpdateTimeout))
    defer cancel()
    if cc.offline {
        ctxAtWork = ctx
    }
    if !cc.offline {
        time.Sleep(time.Second * 2)
    }
	if contentTypes == nil {
		contentTypes = spaceContentTypes
	} else {
		for _, contentType := range contentTypes {
			if !stringSliceContains(spaceContentTypes, contentType) {
				return fmt.Errorf("UpdateCache: Content Type %q not available in this space", contentType)
			}
		}
	}
	if cc.sync {
		return cc.syncCache(ctxAtWork, contentTypes)
	}
	cc.cacheWorkerOnce.Do(func() {
		go cc.cacheWorker(ctxAtWork, contentTypes, cacheAssets)
	})
	if len(cc.cacheQueue) == 0 {
		if cc.logFn != nil && cc.logLevel <= LogInfo {
            cc.logFn(map[string]interface{}{"task":"UpdateCache"}, LogInfo, InfoCacheUpdateQueued)
        }
        cc.cacheQueue <- struct{}{}
		select {
        case <-cc.cacheDone:
            if cc.logFn != nil && cc.logLevel <= LogInfo {
                cc.logFn(map[string]interface{}{"task": "UpdateCache"}, LogInfo, InfoCacheUpdateDone)
            }
        case <-ctxAtWork.Done():
            if cc.logFn != nil && cc.logLevel <= LogInfo {
                cc.logFn(map[string]interface{}{"task": "UpdateCache"}, LogInfo, InfoCacheUpdateCanceled)
            }
        }
        cc.cacheInit = true
		if cc.logFn != nil && cc.logLevel <= LogInfo {
            cc.logFn(map[string]interface{}{"task":"UpdateCache"}, LogInfo, InfoCacheUpdateDone)
        }
        return nil
	}
    if cc.logFn != nil && cc.logLevel <= LogInfo {
        cc.logFn(map[string]interface{}{"task":"UpdateCache"}, LogInfo, InfoCacheUpdateSkipped)
    }
	return nil
}

func (cc *ContentfulClient) syncCache(ctx context.Context, contentTypes []string) error {
	start := time.Now()
	cc.Cache.contentTypes = contentTypes
	if cc.logFn != nil && cc.logLevel <= LogInfo {
			cc.logFn(map[string]interface{}{"task": "syncCache"}, LogInfo, InfoCacheUpdateQueued)
	}
	for {
		col := cc.Client.Entries.Sync(
			cc.SpaceID,
			cc.syncToken == "",
			cc.syncToken,
		)
		col.GetAll()
		cc.syncToken = col.SyncToken
		cc.cacheInit = true
		if len(col.Items) == 0 {
			if cc.logFn != nil && cc.logLevel <= LogInfo {
				cc.logFn(map[string]interface{}{"time elapsed": fmt.Sprint(time.Since(start)), "task": "syncCache"}, LogInfo, InfoUpdateCacheTime)
			}
			return nil
		}
		var entries []*contentful.Entry
		var assets []*contentful.Asset
		for _, item := range col.Items {
			entry := &contentful.Entry{}
			byteArray, _ := json.Marshal(item)
			errEntry := json.NewDecoder(bytes.NewReader(byteArray)).Decode(entry)
			if errEntry == nil && entry.Sys != nil && (entry.Sys.Type == sysTypeAsset || entry.Sys.Type == sysTypeDeletedAsset) {
				asset := &contentful.Asset{}
				errAsset := json.NewDecoder(bytes.NewReader(byteArray)).Decode(asset)
				if errAsset != nil {
					continue
				}
				if asset.Sys != nil {
					assets = append(assets, asset)
				}
				continue
			}
			if entry.Sys != nil {
				entries = append(entries, entry)
			}
		}
		for _, entry := range entries {
			switch entry.Sys.Type {
			case sysTypeEntry:
				if !stringSliceContains(spaceContentTypes, entry.Sys.ContentType.Sys.ID) {
					continue
				}
				updateCacheForContentTypeAndEntity(ctx, cc, entry.Sys.ContentType.Sys.ID, entry.Sys.ID, entry, false)
			case sysTypeDeletedEntry:
				cc.cacheMutex.idContentTypeMapGcLock.RLock()
				contentType := cc.Cache.idContentTypeMap[entry.Sys.ID]
				cc.cacheMutex.idContentTypeMapGcLock.RUnlock()
				updateCacheForContentTypeAndEntity(ctx, cc, contentType, entry.Sys.ID, entry, true)
			default:
			}
		}
		for _, asset := range assets {
			switch asset.Sys.Type {
			case sysTypeAsset:
				updateCacheForContentTypeAndEntity(ctx, cc, assetWorkerType, asset.Sys.ID, asset, false)
			case sysTypeDeletedAsset:
				updateCacheForContentTypeAndEntity(ctx, cc, assetWorkerType, asset.Sys.ID, nil, true)
			default:
			}
		}
	}
}

func (cc *ContentfulClient) cacheWorker(ctx context.Context, contentTypes []string, cacheAssets bool) {
	if cc.logFn != nil && cc.logLevel <= LogInfo {
        cc.logFn(map[string]interface{}{"task":"UpdateCache"}, LogInfo, InfoCacheWorkerStart)
    }
	for range cc.cacheQueue {
	    cc.cacheSpace(ctx, contentTypes, cacheAssets)
		cc.cacheDone <- struct{}{}
	}
}
func (cc *ContentfulClient) cacheSpace(ctx context.Context, contentTypes []string, cacheAssets bool) {
    start := time.Now()
    tempCache := &ContentfulCache{
        contentTypes:     contentTypes,
        idContentTypeMap: map[string]string{},
        parentMap:        map[string][]EntryReference{},
    }
    if cacheAssets {
        contentTypes = append([]string{assetWorkerType}, contentTypes...)
    }
    _, errCanWeEvenConnect := cc.Client.Spaces.Get(cc.SpaceID)
    cc.cacheMutex.sharedDataGcLock.RLock()
    offlinePreviousState := cc.offline
    cc.cacheMutex.sharedDataGcLock.RUnlock()
    if errCanWeEvenConnect != nil {
        if len(cc.offlineTemp.Entries) > 0 && (cc.Cache == nil || offlinePreviousState) {
            if cc.logFn != nil && cc.logLevel <= LogInfo {
                cc.logFn(map[string]interface{}{"task": "UpdateCache"}, LogInfo, InfoFallingBackToFile)
            }
            cc.cacheMutex.sharedDataGcLock.Lock()
            cc.offline = true
            cc.cacheMutex.sharedDataGcLock.Unlock()
        } else {
            if cc.logFn != nil && cc.logLevel <= LogInfo {
                cc.logFn(map[string]interface{}{"task": "UpdateCache"}, LogInfo, InfoPreservingExistingCache)
            }
        }
    }
    results := make(chan ContentTypeResult, 16)
    resultsDone := make(chan struct{})
    contentTypeChan := make(chan string)
    group, gctx := errgroup.WithContext(ctx)
    for i := 0; i < cacheUpdateConcurrency; i++ {
        group.Go(func() error {
            for contentType := range contentTypeChan {
                err := updateCacheForContentType(gctx, results, cc, tempCache, contentType)
                if err != nil {
                    if cc.logFn != nil && cc.logLevel <= LogInfo {
                        cc.logFn(map[string]interface{}{"task": "UpdateCache", "contentType": contentType}, LogError, err.Error())
                    }
                    return err
                }
            }
            return nil
        })
    }
    go func() {
        for _, contentType := range contentTypes {
            contentTypeChan <- contentType
        }
        close(contentTypeChan)
    }()
    go func() {
        for res := range results {
            tempCache.idContentTypeMap[res.EntryID] = res.ContentType
            for childID, references := range res.References {
                tempCache.parentMap[childID] = append(tempCache.parentMap[childID], references...)
            }
        }
        resultsDone <- struct{}{}
    }()
    err := group.Wait()
    close(results)
    if err != nil {
        // drain contentTypeChan
		for range contentTypeChan {
        }
        cc.cacheMutex.sharedDataGcLock.Lock()
        cc.offline = offlinePreviousState
        cc.cacheMutex.sharedDataGcLock.Unlock()
        if cc.logFn != nil && cc.logLevel <= LogInfo {
            cc.logFn(map[string]interface{}{"task": "UpdateCache"}, LogError, err.Error())
        }
        return
    }
    // Signal that the cache build is done
    <-resultsDone

    if cc.logFn != nil && cc.logLevel <= LogInfo {
        cc.logFn(map[string]interface{}{"time elapsed": fmt.Sprint(time.Since(start)), "task": "UpdateCache"}, LogInfo, InfoUpdateCacheTime)
    }
    cc.cacheMutex.fullCacheGcLock.Lock()
    defer cc.cacheMutex.fullCacheGcLock.Unlock()
    cc.Cache = tempCache
    cc.cacheMutex.sharedDataGcLock.Lock()
    cc.offline = offlinePreviousState
    cc.cacheMutex.sharedDataGcLock.Unlock()
}

func ToAssetReference(asset *contentful.Asset) (refSys ContentTypeSys) {
	refSys.Sys.ID = asset.Sys.ID
	refSys.Sys.Type = FieldTypeLink
	refSys.Sys.LinkType = FieldLinkTypeAsset
	return
}

func (cc *ContentfulClient) UpdateCacheForEntity(ctx context.Context, sysType string, contentType string, entityID string) error {
	if sysType == sysTypeEntry && cc.entryMapForContentTypeIsNil(contentType) {
		return fmt.Errorf("UpdateCacheForEntity: Content Type %q not available in cache", contentType)
	}
	if sysType == sysTypeAsset {
		contentType = assetWorkerType
	}
	if contentType != assetWorkerType && !stringSliceContains(spaceContentTypes, contentType) {
		return fmt.Errorf("UpdateCache: Content Type %q not available in this space", contentType)
	}
	return updateCacheForContentTypeAndEntity(ctx, cc, contentType, entityID, nil, false)
}

func FieldToObject(jsonField interface{}, targetObject interface{}) error {
	byteArray, err := json.Marshal(jsonField)
	if err != nil {
		return err
	}
	err = json.Unmarshal(byteArray, &targetObject)
	if err != nil {
		return err
	}
	return nil
}

func (cc *ContentfulClient) cacheGcAssetByID(ctx context.Context, id string, asset *contentful.Asset) error {
	if asset == nil {
		if cc.Client == nil {
			return errors.New("cacheGcAssetByID: No client available")
		}
		col := cc.Client.Assets.List(cc.SpaceID)
		col.Query.Locale("*").Equal("sys.id", id)
		_, err := col.Next()
		if err != nil {
			return err
		}
		if len(col.Items) == 0 {
			return errors.New("cacheGcAssetByID: Not found " + id)
		}
		item := col.Items[0]
		byt, err := json.Marshal(item)
		if err != nil {
			return err
		}
		err = json.Unmarshal(byt, &asset)
		if err != nil {
			return err
		}	
	}
	for _, loc := range []Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }},{{end}} } {
		if _, ok := asset.Fields.File[string(loc)]; ok {
			asset.Fields.File[string(loc)].URL = "https:" + asset.Fields.File[string(loc)].URL
		}
	}
	cc.cacheMutex.assetsGcLock.Lock()
	cc.Cache.assets[id] = asset
	cc.cacheMutex.assetsGcLock.Unlock()
	return nil
}

func (cc *ContentfulClient) deleteAssetFromCache(key string) error {
	if cc.Cache == nil || cc.cacheMutex == nil {
    		return errors.New("no cache available")
    	}
    cc.cacheMutex.assetsGcLock.Lock()
	if _, ok := cc.Cache.assets[key]; ok {
		delete(cc.Cache.assets, key)
		cc.cacheMutex.assetsGcLock.Unlock()
		return nil
	}
	cc.cacheMutex.assetsGcLock.Unlock()
	return errors.New("asset not found in cache, could not delete")
}

func (cc *ContentfulClient) entryMapForContentTypeIsNil(contentType string) bool {
	switch contentType {
	{{ range $index , $contentType := $contentTypes }}
	case ContentType{{ firstCap $contentType.Sys.ID }}:
		if cc.Cache.entryMaps.{{ $contentType.Sys.ID }} == nil {
		return true
	}
	{{ end }}
	}
	return false
}

func getContentfulAPIClient(clientMode ClientMode, clientKey string) (*contentful.Contentful, error) {
	switch clientMode {
	case ClientModeCDA:
		return contentful.NewCDA(clientKey), nil
	case ClientModeCPA:
		return contentful.NewCPA(clientKey), nil
	case ClientModeCMA:
		return contentful.NewCMA(clientKey), nil
	default:
		return nil, errors.New("NewContentfulClient: Unknown ClientMode")
	}
}

func (cc *ContentfulClient) getAllAssets(tryCacheFirst bool) (map[string]*contentful.Asset, error) {
	if cc == nil || cc.Client == nil {
		return nil, errors.New("getAllAssets: No client available")
	}
	if cc.cacheInit && cc.Cache.assets != nil && tryCacheFirst {
		return cc.Cache.assets, nil
	}
	allItems := []interface{}{}
	assets := map[string]*contentful.Asset{}
	if cc.offline {
		for _, asset := range cc.offlineTemp.Assets {
			allItems = append(allItems,asset)
		}
	} else {
		col := cc.Client.Assets.List(cc.SpaceID)
		col.Query.Locale("*").Limit(assetPageSize)
		for {
			_, err := col.Next()
			if err != nil {
				return nil, err
			}
			allItems = append(allItems, col.Items...)
			if uint16(len(col.Items)) < assetPageSize {
				break
			}
		}
	}
	for _, item := range allItems {
		asset := contentful.Asset{}
		byt, err := json.Marshal(item)
		if err != nil {
			return nil, err
		}
		err = json.Unmarshal(byt, &asset)
		if err != nil {
			return nil, err
		}
		for _, loc := range []Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }},{{end}} } {
			if _, ok := asset.Fields.File[string(loc)]; ok {
				asset.Fields.File[string(loc)].URL = "https:" + asset.Fields.File[string(loc)].URL
			}
		}
		assets[asset.Sys.ID] = &asset
	}
	return assets, nil
}

func getOfflineSpaceFromFile(filename string) (*offlineTemp, error) {
	fileBytes, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("getOfflineSpaceFromFile could not read space export file: %v", err)
	}
	offlineTemp := &offlineTemp{}
	err = json.Unmarshal(fileBytes, offlineTemp)
	if err != nil {
		return nil, fmt.Errorf("getOfflineSpaceFromFile could not parse space export file: %v", err)
	}
	return offlineTemp, nil
}

func (cc *ContentfulClient) optimisticPageSizeGetAll(contentType string, limit uint16) (*contentful.Collection, error) {
	col := cc.Client.Entries.List(cc.SpaceID)
	col.Query.ContentType(contentType).Locale("*").Include(0).Limit(limit)
	allItems := []interface{}{}
	var err error
	for {
		_, err = col.Next()
		if err != nil {
			break
		}
		allItems = append(allItems, col.Items...)
		if uint16(len(col.Items)) < limit {
			break
		}
	}
	col.Items = allItems
	switch errTyped := err.(type) {
	case contentful.ErrorResponse:
		msg := errTyped.Message
		if strings.Contains(msg, "Response size too big") && limit >= 20 {
			smallerPageCol, err := cc.optimisticPageSizeGetAll(contentType, limit/2)
			return smallerPageCol, err
		}
		return nil, err
	case nil:
	default:
		return nil, err
	}
	return col, nil
}

func richTextGetAttribute(htmlLine string, attribute string) string {
	re := regexp.MustCompile(` href=["']([^"']+)["']`)
	matches := re.FindStringSubmatch(htmlLine)
	if len(matches) == 2 {
		return strings.ToLower(matches[1])
	}
	return ""
}

func richTextGetMark(mark string) string {
	switch mark {
	case HtmlItalic, HtmlEm:
		return RichTextMarkItalic
	case HtmlBold, HtmlStrong:
		return RichTextMarkBold
	case HtmlUnderline:
		return RichTextMarkUnderline
	case HtmlCode:
		return RichTextMarkCode
	}
	return ""
}

func richTextHtmlLinesToNode(htmlLines []string, start int, pendingTag string, marks []string, isBasic bool) ([]interface{}, int, bool) {
	nodeSlice := make([]interface{}, 0)
	for i := start; i < len(htmlLines); i++ {
		htmlLine := htmlLines[i]
		if richTextIsHtmlClosingPending(htmlLine, pendingTag) {
			return nodeSlice, i, isBasic
		}
		currentNode := RichTextNode{}
		if richTextIsHtmlTag(htmlLine) {
			tt := richTextHtmlTagType(htmlLine)
			switch tt {
			case HtmlParagraph, HtmlHeading1, HtmlHeading2, HtmlHeading3, HtmlHeading4, HtmlHeading5, HtmlHeading6, HtmlUnorderedList, HtmlOrderedList:
				isBasic = false
				currentNode.NodeType = richTextMapTagNodeType(tt)
				var nextLine int
				currentNode.Content, nextLine, isBasic = richTextHtmlLinesToNode(htmlLines, i+1, tt, marks, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlBlockquote, HtmlListItem:
				isBasic = false
				currentNode.NodeType = richTextMapTagNodeType(tt)
				currentNode.Content = make([]interface{}, 0)
				innerContent, nextLine, isBasic := richTextHtmlLinesToNode(htmlLines, i+1, tt, marks, isBasic)
				if len(innerContent) == 1 {
                    switch innerContent[0].(type) {
                    case RichTextNodeTextNode:
                        currentNode.Content = append(currentNode.Content, RichTextNode{
                            NodeType: RichTextNodeParagraph,
                            Content:  innerContent,
                        })
                    }
                } else {
                    for _, ct := range innerContent {
                        switch ct.(type) {
                        case RichTextNode:
                            currentNode.Content = append(currentNode.Content, ct)
                        case RichTextNodeTextNode:
                            currentNode.Content = append(currentNode.Content, RichTextNode{
                                NodeType: RichTextNodeParagraph,
                                Content:  []interface{}{ct},
                            })
                        }
                    }
                }
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlCode:
				isBasic = false
				currentNode.NodeType = RichTextNodeParagraph
				var nextLine int
				currentNode.Content, nextLine, isBasic = richTextHtmlLinesToNode(htmlLines, i+1, HtmlCode, []string{HtmlCode}, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlAnchor:
				isBasic = false
				currentNode.NodeType = RichTextNodeHyperlink
				var nextLine int
				anchorURI := richTextGetAttribute(htmlLine, HtmlAttributeHref)
				if anchorURI == "" {
					anchorURI = "/"
				}
				currentNode.Data = RichTextData{URI: anchorURI}
				currentNode.Content, nextLine, isBasic = richTextHtmlLinesToNode(htmlLines, i+1, tt, marks, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlHorizontalRule:
				isBasic = false
				currentNode.NodeType = RichTextNodeHR
				currentNode.Content = make([]interface{}, 0)
				nodeSlice = append(nodeSlice, currentNode)
			case HtmlItalic, HtmlEm, HtmlBold, HtmlStrong, HtmlUnderline:
				marks = append(marks, tt)
			case HtmlBreak:
				if len(nodeSlice) > 0 {
					myNode := nodeSlice[len(nodeSlice)-1]
					switch myNodeTyped := myNode.(type) {
					case RichTextNodeTextNode:
						if myNodeTyped.NodeType == RichTextNodeText {
							myNodeTyped.Value += "\n"
							nodeSlice[len(nodeSlice)-1] = myNodeTyped
						}
					}
				}
			}
			continue //unsupported tags will be ignored but content is preserved
		}
		if richTextIsHtmlClosingTag(htmlLine) {
			continue //closing tags that are not pending equal to unknown
		}
		if htmlLine == " " {
			continue
		}
		currentNodeTextNode := RichTextNodeTextNode{}
		currentNodeTextNode.NodeType = RichTextNodeText
		currentNodeTextNode.Marks = []RichTextMark{}
		currentNodeTextNode.Value = htmlLine
		for _, mark := range marks {
			currentNodeTextNode.Marks = append(currentNodeTextNode.Marks, RichTextMark{
				Type: richTextGetMark(mark),
			})
		}
		marks = nil
        if pendingTag == "" {
            nodeSlice = append(nodeSlice, RichTextNode{
                NodeType: RichTextNodeParagraph,
                Content:  []interface{}{currentNodeTextNode},
            })
        } else {
            nodeSlice = append(nodeSlice, currentNodeTextNode)
        }
	}
	return nodeSlice, -1, isBasic
}

func richTextIsHtmlClosingPending(htmlLine, tag string) bool {
	return regexp.MustCompile(`</` + strings.ToLower(tag) + `.+$`).MatchString(strings.ToLower(htmlLine))
}

func richTextIsHtmlClosingTag(htmlLine string) bool {
	return regexp.MustCompile(`</[a-zA-Z]+.+$`).MatchString(htmlLine)
}

func richTextIsHtmlTag(htmlLine string) bool {
	return regexp.MustCompile(`<[a-zA-Z]+.+$`).MatchString(htmlLine)
}

func richTextMapTagNodeType(tag string) string {
	switch tag {
	case HtmlParagraph:
		return RichTextNodeParagraph
	case HtmlAnchor:
		return RichTextNodeHyperlink
	case HtmlHeading1:
		return RichTextNodeHeading1
	case HtmlHeading2:
		return RichTextNodeHeading2
	case HtmlHeading3:
		return RichTextNodeHeading3
	case HtmlHeading4:
		return RichTextNodeHeading4
	case HtmlHeading5:
		return RichTextNodeHeading5
	case HtmlHeading6:
		return RichTextNodeHeading6
	case HtmlBlockquote:
		return RichTextNodeBlockquote
	case HtmlUnorderedList:
		return RichTextNodeUnorderedList
	case HtmlOrderedList:
		return RichTextNodeOrderedList
	case HtmlListItem:
		return RichTextNodeListItem
	}
	return ""
}

func (ts richTextHtmlTags) richTextHtmlTagsOpen(w io.Writer) {

	for _, t := range ts {
		if t.customHTML != "" {
			w.Write([]byte(t.customHTML))
			continue
		}
		tagString := "<" + t.name
		if len(t.attrs) > 0 {
			for name, value := range t.attrs {
				tagString += " " + name + `="` + html.EscapeString(value) + `"`
			}
		}
		w.Write([]byte(tagString + ">"))
	}
}

func (ts richTextHtmlTags) richTextHtmlTagsClose(w io.Writer) {
	for _, t := range ts {
		if t.customHTML != "" {
			continue
		}
		w.Write([]byte("</" + t.name + ">"))
	}
}

func richTextHtmlTagType(htmlLine string) string {
	re := regexp.MustCompile(`^<([a-zA-Z0-9]+)[\s]*>*`)
	matches := re.FindStringSubmatch(htmlLine)
	if len(matches) == 2 {
		return strings.ToLower(matches[1])
	}
	return ""
}

func (n *RichTextGenericNode) richTextRenderHTML(w io.Writer, linkResolver LinkResolverFunc, entryLinkResolver EntryLinkResolverFunc, imageResolver ImageResolverFunc, embeddedEntryResolver EmbeddedEntryResolverFunc, locale Locale) (err error) {
	if linkResolver == nil {
		linkResolver = func(url string) (transformedAttrs map[string]string, err error) {
			return map[string]string{
				"href": url,
			}, nil
		}
	}
	if entryLinkResolver == nil {
		entryLinkResolver = func(entryID string, locale Locale) (transformedAttrs map[string]string, err error) {
			return map[string]string{}, nil
		}
	}
	if embeddedEntryResolver == nil {
		embeddedEntryResolver = func(entryID string, locale Locale) (htmlSnippet string, err error) {
			return "", nil
		}
	}
	tags := richTextHtmlTags{}
	switch n.NodeType {
	case RichTextNodeParagraph:
		tags = []richTextHtmlTag{ {name: HtmlParagraph} }
	case RichTextNodeHeading1:
		tags = []richTextHtmlTag{ {name: HtmlHeading1} }
	case RichTextNodeHeading2:
		tags = []richTextHtmlTag{ {name: HtmlHeading2} }
	case RichTextNodeHeading3:
		tags = []richTextHtmlTag{ {name: HtmlHeading3} }
	case RichTextNodeHeading4:
		tags = []richTextHtmlTag{ {name: HtmlHeading4} }
	case RichTextNodeHeading5:
		tags = []richTextHtmlTag{ {name: HtmlHeading5} }
	case RichTextNodeHeading6:
		tags = []richTextHtmlTag{ {name: HtmlHeading6} }
	case RichTextNodeOrderedList:
		tags = []richTextHtmlTag{ {name: HtmlOrderedList} }
	case RichTextNodeUnorderedList:
		tags = []richTextHtmlTag{ {name: HtmlUnorderedList} }
	case RichTextNodeListItem:
		tags = []richTextHtmlTag{ {name: HtmlListItem} }
	case RichTextNodeHR:
		tags = []richTextHtmlTag{ {name: HtmlHorizontalRule} }
	case RichTextNodeBlockquote:
		tags = []richTextHtmlTag{ {name: HtmlBlockquote} }
	case RichTextNodeText:
		tags = []richTextHtmlTag{}
	case RichTextNodeHyperlink:
		if n.Data != nil {
            uri := n.Data["uri"]
            attrs := map[string]string{}
            switch uriString := uri.(type) {
            case string:
                if uriString != "" {
                    resolvedAttrs, errResolveAttrs := linkResolver(uriString)
                    if errResolveAttrs != nil {
                        err = errResolveAttrs
                        return
                    }
                    attrs = resolvedAttrs
                }
            }
            tags = []richTextHtmlTag{richTextHtmlTag{name: HtmlAnchor, attrs: attrs}}
        }
	case RichTextNodeEntryHyperlink:
		if n.Data != nil {
            target := n.Data["target"]
            attrs := map[string]string{}
            switch target.(type) {
            case map[string]interface{}:
                targetSys, ok := target.(map[string]interface{})["sys"]
                if ok {
                    entryID := targetSys.(map[string]interface{})["id"].(string)
                    resolvedAttrs, errResolveAttrs := entryLinkResolver(entryID, locale)
                    if errResolveAttrs != nil {
                        err = errResolveAttrs
                        return
                    }
                    attrs = resolvedAttrs
                }
            }
            tags = []richTextHtmlTag{richTextHtmlTag{name: HtmlAnchor, attrs: attrs}}
        }
	case RichTextNodeEmbeddedAsset:
		if imageResolver == nil {
			return errors.New("can't resolve image asset URL")
		}
		dataObj := RichTextData{}
		byt, err := json.Marshal(n.Data)
		if err != nil {
			return err
		}
		err = json.Unmarshal(byt, &dataObj)
		if err != nil {
			return err
		}
		if dataObj.Target == nil {
			return errors.New("data target is empty")
		}
		attrs, customHTML, err := imageResolver(dataObj.Target.Sys.ID, locale)
		if err != nil {
			return err
		}
		tags = []richTextHtmlTag{richTextHtmlTag{name: HtmlImage, attrs: attrs, customHTML: customHTML}}
	case RichTextNodeEmbeddedEntry:
		dataObj := RichTextData{}
		byt, errMarshal := json.Marshal(n.Data)
		if errMarshal != nil {
			return errMarshal
		}
		errUnmarshal := json.Unmarshal(byt, &dataObj)
		if errUnmarshal != nil {
			return errUnmarshal
		}
		if dataObj.Target == nil {
			return errors.New("data target is empty")
		}
		rawHTML, errResolve := embeddedEntryResolver(dataObj.Target.Sys.ID, locale)
		if errResolve != nil {
			return errResolve
		}
		w.Write([]byte(rawHTML))
		return
	case RichTextNodeTable:
		tags = []richTextHtmlTag{ {name: HtmlTable} }
	case RichTextNodeTableRow:
		tags = []richTextHtmlTag{ {name: HtmlTableRow} }
	case RichTextNodeTableHeaderCell:
		tags = []richTextHtmlTag{ {name: HtmlTableHeaderCell} }
	case RichTextNodeTableCell:
		tags = []richTextHtmlTag{ {name: HtmlTableCell} }
	default:
	}
	for _, m := range n.Marks {
		markTag := ""
		switch m.Type {
		case RichTextMarkBold:
			markTag = HtmlBold
		case RichTextMarkItalic:
			markTag = HtmlItalic
		case RichTextMarkUnderline:
			markTag = HtmlUnderline
		case RichTextMarkCode:
			markTag = HtmlCode
		case RichTextNodeBlockquote:
			markTag = HtmlBlockquote
		}
		if markTag != "" {
			tags = append(tags, richTextHtmlTag{name: markTag})
		}
	}

	tags.richTextHtmlTagsOpen(w)
	cleanString := strings.Replace(html.EscapeString(n.Value), "\n", "<br/>", -1)
	cleanString = strings.ReplaceAll(cleanString, "\u00a0", " ")
	w.Write([]byte(cleanString))
	for _, subNode := range n.Content {
		errSubNode := subNode.richTextRenderHTML(w, linkResolver, entryLinkResolver, imageResolver, embeddedEntryResolver, locale)
		if errSubNode != nil {
			err = errSubNode
			return
		}
	}
	tags.richTextHtmlTagsClose(w)
	return
}

func stringSliceContains(s []string, e string) bool {
	for _, a := range s {
		if a == e {
			return true
		}
	}
	return false
}

func updateCacheForContentType(ctx context.Context, results chan ContentTypeResult, cc *ContentfulClient, tempCache *ContentfulCache, contentType string) error {
	if ctx.Err() != nil {
		return ctx.Err()
	}
	switch contentType {
	{{ range $index , $contentType := $contentTypes }}
	case ContentType{{ firstCap $contentType.Sys.ID }}:
		all{{ firstCap $contentType.Sys.ID }}, err := cc.cacheAll{{ firstCap $contentType.Sys.ID }}(ctx, results)
		if err != nil {
			return errors.New("updateCacheForContentType failed for contentType {{ $contentType.Sys.ID }}: "+err.Error())
		}
		tempCache.entryMaps.{{ $contentType.Sys.ID }} = all{{ firstCap $contentType.Sys.ID }}
		if cc.logFn != nil && cc.logLevel <= LogInfo {
			cc.logFn(map[string]interface{}{"contentType":"{{ $contentType.Sys.ID }}", "method": "updateCacheForContentType", "size":len(all{{ firstCap $contentType.Sys.ID }})}, LogInfo, InfoCachedAllEntries)
		}
	{{ end }}
	case assetWorkerType:
		allAssets, err := cc.getAllAssets(false)
		if err != nil {
			return errors.New("updateCacheForContentType failed for assets")
		}
		tempCache.assets = allAssets
		if cc.logFn != nil && cc.logLevel <= LogInfo {
			cc.logFn(map[string]interface{}{"contentType": "asset", "method": "updateCacheForContentType", "size": len(allAssets)}, LogInfo, InfoCachedAllAssets)
		}
	}
	return nil
}

func updateCacheForContentTypeAndEntity(ctx context.Context, cc *ContentfulClient, contentType string, entityID string, entityPayload interface{}, entryDelete bool) error {
	if ctx.Err() != nil {
		return ctx.Err()
	}
	var entityEntry *contentful.Entry
	var entityAsset *contentful.Asset
	switch contentType {
	case assetWorkerType:
		if entryDelete {
			err := cc.deleteAssetFromCache(entityID)
			if err != nil {
				return err
			}
		} else {
			if entityPayload != nil {
				entityAsset = entityPayload.(*contentful.Asset)
			}
			err := cc.cacheGcAssetByID(ctx, entityID, entityAsset)
			if err != nil {
				return err
			}
		}
		if cc.logFn != nil && cc.logLevel <= LogInfo && entityPayload == nil {
			cc.logFn(map[string]interface{}{"contentType": "Asset", "method": "updateCacheForContentTypeAndEntity", "entityID": entityID}, LogInfo, InfoUpdatedEntityCache)
		}
	{{ range $index , $contentType := $contentTypes }}
	case ContentType{{ firstCap $contentType.Sys.ID }}:
		if entityPayload != nil {
			entityEntry = entityPayload.(*contentful.Entry)
		}
		err := cc.cache{{ firstCap $contentType.Sys.ID }}ByID(ctx, entityID, entityEntry, entryDelete)
		if err != nil {
			return err
		}
		if cc.logFn != nil && cc.logLevel <= LogInfo && entityPayload == nil {
			cc.logFn(map[string]interface{}{"contentType": "{{ $contentType.Sys.ID }}", "method": "updateCacheForContentTypeAndEntity", "entityID": entityID}, LogInfo, InfoUpdatedEntityCache)
		}
	{{ end }}
	}
	return nil
}

func commonGetParents(cc *ContentfulClient, id string, contentType []string) (parents []EntryReference, err error) {
	parents = []EntryReference{}
	if cc.cacheInit {
		if len(contentType) != 0 {
			for _, parent := range cc.Cache.parentMap[id] {
				if parent.ContentType == contentType[0] {
					parents = append(parents, parent)
				}
			}
			return parents, nil
		}
		return cc.Cache.parentMap[id], nil
	}
	col := cc.Client.Entries.List(cc.SpaceID)
	col.Query.Equal("links_to_entry", id).Locale("*")
	_, err = col.GetAll()
	if err != nil {
		return nil, errors.New("GetParents: " + err.Error())
	}
	for _, item := range col.Items {
    		var entry contentful.Entry
    		byteArray, err := json.Marshal(item)
    		if err != nil {
    			return nil, err
    		}
    		err = json.Unmarshal(byteArray, &entry)
    		if err != nil {
    			return nil, err
    		}
    		if len(contentType) == 1 && contentType[0] != entry.Sys.ContentType.Sys.ID {
    			continue
    		}
    		switch entry.Sys.ContentType.Sys.ID { {{ range $index , $contentType := $contentTypes }}
	        case ContentType{{ firstCap $contentType.Sys.ID }}:
		    	var parentVO Cf{{ firstCap $contentType.Sys.ID }}
                byteArray, _ := json.Marshal(item)
                err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&parentVO)
                if err != nil {
                    return nil, errors.New("GetParents: " + err.Error())
                }
                parentVO.CC = cc
                parents = append(
                    parents, EntryReference{
                        ContentType: entry.Sys.ContentType.Sys.ID,
                        ID:          entry.Sys.ID,
                        VO:          &parentVO,
                    })
            {{ end }} }
	}
	return parents, nil
}

// Unicode clean-up

func cleanUpStringField(field map[string]string) map[string]string {
	cleanField := map[string]string{}
	for locale, value := range field {
		cleanField[locale] = stripInvisibleUnicodeChars(value)
	}
	return cleanField
}

func cleanUpStringSliceField(field map[string][]string) map[string][]string {
	cleanField := map[string][]string{}
	for locale, value := range field {
		cleanLocalizedSliceElems := []string{}
		for _, sliceElem := range value {
			cleanLocalizedSliceElems = append(cleanLocalizedSliceElems, stripInvisibleUnicodeChars(sliceElem))
		}
		cleanField[locale] = cleanLocalizedSliceElems
	}
	return cleanField
}

func cleanUpRichTextField(field map[string]interface{}) map[string]interface{} {
	cleanField := map[string]interface{}{}
	for locale, value := range field {
		node, err := objectToRichTextGenericNode(value)
		if err != nil {
			return field
		}
		cleanNode := cleanUpRichTextIterateNode(node)
		cleanField[locale] = cleanNode
	}
	return cleanField
}

func cleanUpRichTextIterateNode(node *RichTextGenericNode) *RichTextGenericNode {
	cleanNode := &RichTextGenericNode{
		NodeType: node.NodeType,
		Data:     node.Data,
		Value:    stripInvisibleUnicodeChars(node.Value),
		Marks:    node.Marks,
	}
	for _, childNode := range node.Content {
		cleanNode.Content = append(cleanNode.Content, cleanUpRichTextIterateNode(childNode))
	}
	return cleanNode
}

func isFieldRichText(field map[string]interface{}) bool {
	for _, value := range field {
		if value == nil {
			continue
		}
		node, err := objectToRichTextGenericNode(value)
		if err != nil {
			return false
		}
		if node.NodeType == "document" && node.Content != nil {
			return true
		}
	}
	return false
}

func objectToRichTextGenericNode(value interface{}) (*RichTextGenericNode, error) {
	node := &RichTextGenericNode{}
	byt, err := json.Marshal(value)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(byt, node)
	if err != nil {
		return nil, err
	}
	return node, nil
}

func stripInvisibleUnicodeChars(dirty string) string {
	clean := strings.Map(func(r rune) rune {
		if unicode.IsGraphic(r) || unicode.IsControl(r) {
			return r
		}
		return -1
	}, dirty)
	return clean
}
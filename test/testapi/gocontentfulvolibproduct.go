// Code generated by https://github.com/foomo/gocontentful - DO NOT EDIT.
package testapi

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	"github.com/foomo/contentful"
)

const ContentTypeProduct = "product"

// ---Product private methods---

// ---Product public methods---

func (cc *ContentfulClient) GetAllProduct(ctx context.Context) (voMap map[string]*CfProduct, err error) {
	if cc == nil {
		return nil, errors.New("GetAllProduct: No client available")
	}
	cc.cacheMutex.sharedDataGcLock.RLock()
	cacheInit := cc.cacheInit
	optimisticPageSize := cc.optimisticPageSize
	cc.cacheMutex.sharedDataGcLock.RUnlock()
	if cacheInit {
		return cc.Cache.entryMaps.product, nil
	}
	col, err := cc.optimisticPageSizeGetAll(ctx, "product", optimisticPageSize)
	if err != nil {
		return nil, err
	}
	allProduct, err := colToCfProduct(col, cc)
	if err != nil {
		return nil, err
	}
	productMap := map[string]*CfProduct{}
	for _, product := range allProduct {
		productMap[product.Sys.ID] = product
	}
	return productMap, nil
}

func (cc *ContentfulClient) GetFilteredProduct(ctx context.Context, query *contentful.Query) (voMap map[string]*CfProduct, err error) {
	if cc == nil || cc.Client == nil {
		return nil, errors.New("getFilteredProduct: No client available")
	}
	col := cc.Client.Entries.List(ctx, cc.SpaceID)
	if query != nil {
		col.Query = *query
	}
	col.Query.ContentType("product").Locale("*").Include(0)
	_, err = col.GetAll()
	if err != nil {
		return nil, errors.New("getFilteredProduct: " + err.Error())
	}
	allProduct, err := colToCfProduct(col, cc)
	if err != nil {
		return nil, errors.New("getFilteredProduct: " + err.Error())
	}
	productMap := map[string]*CfProduct{}
	for _, product := range allProduct {
		productMap[product.Sys.ID] = product
	}
	return productMap, nil
}

func (cc *ContentfulClient) GetProductByTag(ctx context.Context, tagName string) (vos []*CfProduct, err error) {
	if cc == nil || cc.Client == nil {
		return nil, errors.New("GetProductByTag: No client available")
	}
	if !cc.cacheInit {
		return nil, errors.New("GetProductByTag: only available with cache")
	}
	tags, err := cc.getAllTags(ctx, true)
	if err != nil {
		return nil, errors.New("GetProductByTag could not get tags from cache: " + err.Error())
	}
	cc.cacheMutex.productGcLock.RLock()
	defer cc.cacheMutex.productGcLock.RUnlock()
	if _, tagExists := tags[tagName]; !tagExists {
		return nil, nil
	}
	tagID := tags[tagName]
	for _, vo := range cc.Cache.entryMaps.product {
		for _, voTag := range vo.Metadata.Tags {
			if voTag.Sys.ID == tagID {
				vos = append(vos, vo)
			}
		}
	}
	return vos, nil
}

func (cc *ContentfulClient) GetProductByID(ctx context.Context, id string, forceNoCache ...bool) (vo *CfProduct, err error) {
	if cc == nil || cc.Client == nil {
		return nil, errors.New("GetProductByID: No client available")
	}
	if cc.cacheInit && (len(forceNoCache) == 0 || !forceNoCache[0]) {
		cc.cacheMutex.productGcLock.RLock()
		defer cc.cacheMutex.productGcLock.RUnlock()
		vo, ok := cc.Cache.entryMaps.product[id]
		if ok {
			return vo, nil
		}
		return nil, fmt.Errorf("GetProductByID: entry '%s' not found in cache", id)
	}
	col := cc.Client.Entries.List(ctx, cc.SpaceID)
	col.Query.ContentType("product").Locale("*").Include(0).Equal("sys.id", id)
	_, err = col.GetAll()
	if err != nil {
		return nil, err
	}
	if len(col.Items) == 0 {
		return nil, fmt.Errorf("GetProductByID: %s Not found", id)
	}
	vos, err := colToCfProduct(col, cc)
	if err != nil {
		return nil, fmt.Errorf("GetProductByID: Error converting %s to VO: %w", id, err)
	}
	vo = vos[0]
	return
}

func NewCfProduct(contentfulClient ...*ContentfulClient) (cfProduct *CfProduct) {
	cfProduct = &CfProduct{}
	if len(contentfulClient) != 0 && contentfulClient[0] != nil {
		cfProduct.CC = contentfulClient[0]
	}

	cfProduct.Fields.ProductName = map[string]string{}

	cfProduct.Fields.Slug = map[string]string{}

	cfProduct.Fields.ProductDescription = map[string]string{}

	cfProduct.Fields.Sizetypecolor = map[string]string{}

	cfProduct.Fields.Image = map[string][]ContentTypeSys{}

	cfProduct.Fields.Tags = map[string][]string{}

	cfProduct.Fields.Categories = map[string][]ContentTypeSys{}

	cfProduct.Fields.Price = map[string]float64{}

	cfProduct.Fields.Brand = map[string]ContentTypeSys{}

	cfProduct.Fields.SubProduct = map[string]ContentTypeSys{}

	cfProduct.Fields.Quantity = map[string]float64{}

	cfProduct.Fields.Sku = map[string]string{}

	cfProduct.Fields.Website = map[string]string{}

	cfProduct.Fields.SeoText = map[string]interface{}{}

	cfProduct.Fields.Nodes = map[string]interface{}{}

	cfProduct.Sys.ContentType.Sys.ID = "product"
	cfProduct.Sys.ContentType.Sys.Type = FieldTypeLink
	cfProduct.Sys.ContentType.Sys.LinkType = "ContentType"
	return
}
func (vo *CfProduct) GetParents(ctx context.Context, contentType ...string) (parents []EntryReference, err error) {
	if vo == nil {
		return nil, errors.New("GetParents: Value Object is nil")
	}
	if vo.CC == nil {
		return nil, errors.New("GetParents: Value Object has no Contentful Client set")
	}
	return commonGetParents(ctx, vo.CC, vo.Sys.ID, contentType)
}

func (vo *CfProduct) GetPublishingStatus() string {
	if vo == nil {
		return ""
	}
	if vo.Sys.PublishedVersion == 0 {
		return StatusDraft
	}
	if vo.Sys.Version-vo.Sys.PublishedVersion == 1 {
		return StatusPublished
	}
	return StatusChanged
}

// Product Field getters

func (vo *CfProduct) ProductName(locale ...Locale) string {
	if vo == nil {
		return ""
	}
	if vo.CC == nil {
		return ""
	}
	vo.Fields.RWLockProductName.RLock()
	defer vo.Fields.RWLockProductName.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "ProductName()"}, LogError, ErrLocaleUnsupported)
			}
			return ""
		}
	}
	if _, ok := vo.Fields.ProductName[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "ProductName()"}, LogWarn, ErrNotSet)
			}
			return ""
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.ProductName[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "ProductName()"}, LogWarn, ErrNotSetNoFallback)
			}
			return ""
		}
	}
	return vo.Fields.ProductName[string(loc)]
}

func (vo *CfProduct) Slug(locale ...Locale) string {
	if vo == nil {
		return ""
	}
	if vo.CC == nil {
		return ""
	}
	vo.Fields.RWLockSlug.RLock()
	defer vo.Fields.RWLockSlug.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Slug()"}, LogError, ErrLocaleUnsupported)
			}
			return ""
		}
	}
	if _, ok := vo.Fields.Slug[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Slug()"}, LogWarn, ErrNotSet)
			}
			return ""
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.Slug[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Slug()"}, LogWarn, ErrNotSetNoFallback)
			}
			return ""
		}
	}
	return vo.Fields.Slug[string(loc)]
}

func (vo *CfProduct) ProductDescription(locale ...Locale) string {
	if vo == nil {
		return ""
	}
	if vo.CC == nil {
		return ""
	}
	vo.Fields.RWLockProductDescription.RLock()
	defer vo.Fields.RWLockProductDescription.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "ProductDescription()"}, LogError, ErrLocaleUnsupported)
			}
			return ""
		}
	}
	if _, ok := vo.Fields.ProductDescription[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "ProductDescription()"}, LogWarn, ErrNotSet)
			}
			return ""
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.ProductDescription[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "ProductDescription()"}, LogWarn, ErrNotSetNoFallback)
			}
			return ""
		}
	}
	return vo.Fields.ProductDescription[string(loc)]
}

func (vo *CfProduct) Sizetypecolor(locale ...Locale) string {
	if vo == nil {
		return ""
	}
	if vo.CC == nil {
		return ""
	}
	vo.Fields.RWLockSizetypecolor.RLock()
	defer vo.Fields.RWLockSizetypecolor.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Sizetypecolor()"}, LogError, ErrLocaleUnsupported)
			}
			return ""
		}
	}
	if _, ok := vo.Fields.Sizetypecolor[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Sizetypecolor()"}, LogWarn, ErrNotSet)
			}
			return ""
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.Sizetypecolor[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Sizetypecolor()"}, LogWarn, ErrNotSetNoFallback)
			}
			return ""
		}
	}
	return vo.Fields.Sizetypecolor[string(loc)]
}

func (vo *CfProduct) Image(ctx context.Context, locale ...Locale) []*contentful.AssetNoLocale {
	if vo == nil {
		return nil
	}
	if vo.CC == nil {
		return nil
	}
	vo.Fields.RWLockImage.RLock()
	defer vo.Fields.RWLockImage.RUnlock()
	image := []*contentful.AssetNoLocale{}
	loc := DefaultLocale
	reqLoc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		reqLoc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Image()"}, LogError, ErrLocaleUnsupported)
			}
			return nil
		}
	}
	if _, ok := vo.Fields.Image[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Image()"}, LogWarn, ErrNotSet)
			}
			return nil
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.Image[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Image()"}, LogWarn, ErrNotSetNoFallback)
			}
			return nil
		}
	}
	for _, eachLocalizedImage := range vo.Fields.Image[string(loc)] {
		asset, err := vo.CC.GetAssetByID(ctx, eachLocalizedImage.Sys.ID)
		if err != nil {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Image()"}, LogError, ErrNoTypeOfRefAsset)
			}
			continue
		}
		tempAsset := &contentful.AssetNoLocale{}
		tempAsset.Sys = asset.Sys
		tempAsset.Fields = &contentful.FileFieldsNoLocale{}
		if _, ok := asset.Fields.Title[string(reqLoc)]; ok {
			tempAsset.Fields.Title = asset.Fields.Title[string(reqLoc)]
		} else {
			tempAsset.Fields.Title = asset.Fields.Title[string(loc)]
		}
		if _, ok := asset.Fields.Description[string(reqLoc)]; ok {
			tempAsset.Fields.Description = asset.Fields.Description[string(reqLoc)]
		} else {
			tempAsset.Fields.Description = asset.Fields.Description[string(loc)]
		}
		if _, ok := asset.Fields.File[string(reqLoc)]; ok {
			tempAsset.Fields.File = asset.Fields.File[string(reqLoc)]
		} else {
			tempAsset.Fields.File = asset.Fields.File[string(loc)]
		}
		image = append(image, tempAsset)
	}
	return image
}

func (vo *CfProduct) Tags(locale ...Locale) []string {
	if vo == nil {
		return nil
	}
	if vo.CC == nil {
		return nil
	}
	vo.Fields.RWLockTags.RLock()
	defer vo.Fields.RWLockTags.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Tags()"}, LogError, ErrLocaleUnsupported)
			}
			return nil
		}
	}
	if _, ok := vo.Fields.Tags[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Tags()"}, LogWarn, ErrNotSet)
			}
			return nil
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.Tags[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Tags()"}, LogWarn, ErrNotSetNoFallback)
			}
			return nil
		}
	}
	return vo.Fields.Tags[string(loc)]
}

func (vo *CfProduct) Categories(ctx context.Context, locale ...Locale) []*EntryReference {
	if vo == nil {
		return nil
	}
	if vo.CC == nil {
		return nil
	}
	vo.Fields.RWLockCategories.RLock()
	defer vo.Fields.RWLockCategories.RUnlock()
	categories := []*EntryReference{}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Categories()"}, LogError, ErrLocaleUnsupported)
			}
			return nil
		}
	}
	if _, ok := vo.Fields.Categories[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Categories()"}, LogWarn, ErrNotSet)
			}
			return nil
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.Categories[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Categories()"}, LogWarn, ErrNotSetNoFallback)
			}
			return nil
		}
	}
	for _, eachLocalizedCategories := range vo.Fields.Categories[string(loc)] {
		contentType, err := vo.CC.GetContentTypeOfID(ctx, eachLocalizedCategories.Sys.ID)
		if err != nil {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Categories()"}, LogError, ErrNoTypeOfRefEntry)
			}
			continue
		}
		switch contentType {

		case ContentTypeBrand:
			referencedVO, err := vo.CC.GetBrandByID(ctx, eachLocalizedCategories.Sys.ID)
			if err != nil {
				if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
					vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Categories()"}, LogError, err)
				}
				return nil
			}
			categories = append(categories, &EntryReference{ContentType: contentType, ID: eachLocalizedCategories.Sys.ID, VO: referencedVO})

		case ContentTypeCategory:
			referencedVO, err := vo.CC.GetCategoryByID(ctx, eachLocalizedCategories.Sys.ID)
			if err != nil {
				if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
					vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Categories()"}, LogError, err)
				}
				return nil
			}
			categories = append(categories, &EntryReference{ContentType: contentType, ID: eachLocalizedCategories.Sys.ID, VO: referencedVO})

		case ContentTypeProduct:
			referencedVO, err := vo.CC.GetProductByID(ctx, eachLocalizedCategories.Sys.ID)
			if err != nil {
				if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
					vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Categories()"}, LogError, err)
				}
				return nil
			}
			categories = append(categories, &EntryReference{ContentType: contentType, ID: eachLocalizedCategories.Sys.ID, VO: referencedVO})

		}
	}
	return categories
}

func (vo *CfProduct) Price(locale ...Locale) float64 {
	if vo == nil {
		return 0
	}
	if vo.CC == nil {
		return 0
	}
	vo.Fields.RWLockPrice.RLock()
	defer vo.Fields.RWLockPrice.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Price()"}, LogError, ErrLocaleUnsupported)
			}
			return 0
		}
	}
	if _, ok := vo.Fields.Price[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Price()"}, LogWarn, ErrNotSet)
			}
			return 0
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.Price[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Price()"}, LogWarn, ErrNotSetNoFallback)
			}
			return 0
		}
	}
	return vo.Fields.Price[string(loc)]
}

func (vo *CfProduct) Brand(ctx context.Context, locale ...Locale) *EntryReference {
	if vo == nil {
		return nil
	}
	if vo.CC == nil {
		return nil
	}
	vo.Fields.RWLockBrand.RLock()
	defer vo.Fields.RWLockBrand.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Brand()"}, LogError, ErrLocaleUnsupported)
			}
			return nil
		}
	}
	if _, ok := vo.Fields.Brand[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Brand()"}, LogWarn, ErrNotSet)
			}
			return nil
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.Brand[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Brand()"}, LogWarn, ErrNotSetNoFallback)
			}
			return nil
		}
	}
	localizedBrand := vo.Fields.Brand[string(loc)]
	contentType, err := vo.CC.GetContentTypeOfID(ctx, localizedBrand.Sys.ID)
	if err != nil {
		if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
			vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Brand()"}, LogError, ErrNoTypeOfRefEntry)
		}
		return nil
	}
	switch contentType {

	case ContentTypeBrand:
		referencedVO, err := vo.CC.GetBrandByID(ctx, localizedBrand.Sys.ID)
		if err != nil {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Brand()"}, LogError, err)
			}
			return nil
		}
		return &EntryReference{ContentType: contentType, ID: localizedBrand.Sys.ID, VO: referencedVO}

	case ContentTypeCategory:
		referencedVO, err := vo.CC.GetCategoryByID(ctx, localizedBrand.Sys.ID)
		if err != nil {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Brand()"}, LogError, err)
			}
			return nil
		}
		return &EntryReference{ContentType: contentType, ID: localizedBrand.Sys.ID, VO: referencedVO}

	case ContentTypeProduct:
		referencedVO, err := vo.CC.GetProductByID(ctx, localizedBrand.Sys.ID)
		if err != nil {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Brand()"}, LogError, err)
			}
			return nil
		}
		return &EntryReference{ContentType: contentType, ID: localizedBrand.Sys.ID, VO: referencedVO}

	}
	return nil
}

func (vo *CfProduct) SubProduct(ctx context.Context, locale ...Locale) *EntryReference {
	if vo == nil {
		return nil
	}
	if vo.CC == nil {
		return nil
	}
	vo.Fields.RWLockSubProduct.RLock()
	defer vo.Fields.RWLockSubProduct.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "SubProduct()"}, LogError, ErrLocaleUnsupported)
			}
			return nil
		}
	}
	if _, ok := vo.Fields.SubProduct[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "SubProduct()"}, LogWarn, ErrNotSet)
			}
			return nil
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.SubProduct[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "SubProduct()"}, LogWarn, ErrNotSetNoFallback)
			}
			return nil
		}
	}
	localizedSubProduct := vo.Fields.SubProduct[string(loc)]
	contentType, err := vo.CC.GetContentTypeOfID(ctx, localizedSubProduct.Sys.ID)
	if err != nil {
		if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
			vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "SubProduct()"}, LogError, ErrNoTypeOfRefEntry)
		}
		return nil
	}
	switch contentType {

	case ContentTypeBrand:
		referencedVO, err := vo.CC.GetBrandByID(ctx, localizedSubProduct.Sys.ID)
		if err != nil {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "SubProduct()"}, LogError, err)
			}
			return nil
		}
		return &EntryReference{ContentType: contentType, ID: localizedSubProduct.Sys.ID, VO: referencedVO}

	case ContentTypeCategory:
		referencedVO, err := vo.CC.GetCategoryByID(ctx, localizedSubProduct.Sys.ID)
		if err != nil {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "SubProduct()"}, LogError, err)
			}
			return nil
		}
		return &EntryReference{ContentType: contentType, ID: localizedSubProduct.Sys.ID, VO: referencedVO}

	case ContentTypeProduct:
		referencedVO, err := vo.CC.GetProductByID(ctx, localizedSubProduct.Sys.ID)
		if err != nil {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "SubProduct()"}, LogError, err)
			}
			return nil
		}
		return &EntryReference{ContentType: contentType, ID: localizedSubProduct.Sys.ID, VO: referencedVO}

	}
	return nil
}

func (vo *CfProduct) Quantity(locale ...Locale) float64 {
	if vo == nil {
		return 0
	}
	if vo.CC == nil {
		return 0
	}
	vo.Fields.RWLockQuantity.RLock()
	defer vo.Fields.RWLockQuantity.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Quantity()"}, LogError, ErrLocaleUnsupported)
			}
			return 0
		}
	}
	if _, ok := vo.Fields.Quantity[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Quantity()"}, LogWarn, ErrNotSet)
			}
			return 0
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.Quantity[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Quantity()"}, LogWarn, ErrNotSetNoFallback)
			}
			return 0
		}
	}
	return vo.Fields.Quantity[string(loc)]
}

func (vo *CfProduct) Sku(locale ...Locale) string {
	if vo == nil {
		return ""
	}
	if vo.CC == nil {
		return ""
	}
	vo.Fields.RWLockSku.RLock()
	defer vo.Fields.RWLockSku.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Sku()"}, LogError, ErrLocaleUnsupported)
			}
			return ""
		}
	}
	if _, ok := vo.Fields.Sku[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Sku()"}, LogWarn, ErrNotSet)
			}
			return ""
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.Sku[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Sku()"}, LogWarn, ErrNotSetNoFallback)
			}
			return ""
		}
	}
	return vo.Fields.Sku[string(loc)]
}

func (vo *CfProduct) Website(locale ...Locale) string {
	if vo == nil {
		return ""
	}
	if vo.CC == nil {
		return ""
	}
	vo.Fields.RWLockWebsite.RLock()
	defer vo.Fields.RWLockWebsite.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Website()"}, LogError, ErrLocaleUnsupported)
			}
			return ""
		}
	}
	if _, ok := vo.Fields.Website[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Website()"}, LogWarn, ErrNotSet)
			}
			return ""
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.Website[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Website()"}, LogWarn, ErrNotSetNoFallback)
			}
			return ""
		}
	}
	return vo.Fields.Website[string(loc)]
}

func (vo *CfProduct) SeoText(locale ...Locale) *interface{} {
	if vo == nil {
		return nil
	}
	if vo.CC == nil {
		return nil
	}
	vo.Fields.RWLockSeoText.RLock()
	defer vo.Fields.RWLockSeoText.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "SeoText()"}, LogError, ErrLocaleUnsupported)
			}
			return nil
		}
	}
	if _, ok := vo.Fields.SeoText[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "SeoText()"}, LogWarn, ErrNotSet)
			}
			return nil
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.SeoText[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "SeoText()"}, LogWarn, ErrNotSetNoFallback)
			}
			return nil
		}
	}
	seoText := vo.Fields.SeoText[string(loc)]
	return &seoText
}

func (vo *CfProduct) Nodes(locale ...Locale) *interface{} {
	if vo == nil {
		return nil
	}
	if vo.CC == nil {
		return nil
	}
	vo.Fields.RWLockNodes.RLock()
	defer vo.Fields.RWLockNodes.RUnlock()
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel <= LogError {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Nodes()"}, LogError, ErrLocaleUnsupported)
			}
			return nil
		}
	}
	if _, ok := vo.Fields.Nodes[string(loc)]; !ok {
		if _, ok := localeFallback[loc]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Nodes()"}, LogWarn, ErrNotSet)
			}
			return nil
		}
		loc = localeFallback[loc]
		if _, ok := vo.Fields.Nodes[string(loc)]; !ok {
			if vo.CC.logFn != nil && vo.CC.logLevel == LogDebug {
				vo.CC.logFn(map[string]interface{}{"content type": vo.Sys.ContentType.Sys.ID, "entry ID": vo.Sys.ID, "method": "Nodes()"}, LogWarn, ErrNotSetNoFallback)
			}
			return nil
		}
	}
	nodes := vo.Fields.Nodes[string(loc)]
	return &nodes
}

func (vo *CfProduct) IsArchived(ctx context.Context) (bool, error) {
	if vo == nil {
		return false, errors.New("IsArchived: Value Object is nil")
	}
	if vo.CC == nil {
		return false, errors.New("IsArchived: Value Object has nil Contentful client")
	}
	if vo.CC.clientMode != ClientModeCMA {
		return false, errors.New("IsArchived: Only available in ClientModeCMA")
	}
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return false, errors.New("CfProduct IsArchived: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return false, errors.New("CfProduct IsArchived: Can't unmarshal JSON into CF entry")
	}
	return len(cfEntry.Sys.ArchivedAt) > 0, nil
}

// Product Field setters

func (vo *CfProduct) SetProductName(productName string, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetProductName(productName: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockProductName.Lock()
	defer vo.Fields.RWLockProductName.Unlock()
	if vo.Fields.ProductName == nil {
		vo.Fields.ProductName = make(map[string]string)
	}
	vo.Fields.ProductName[string(loc)] = productName
	return
}

func (vo *CfProduct) SetSlug(slug string, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetSlug(slug: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockSlug.Lock()
	defer vo.Fields.RWLockSlug.Unlock()
	if vo.Fields.Slug == nil {
		vo.Fields.Slug = make(map[string]string)
	}
	vo.Fields.Slug[string(loc)] = slug
	return
}

func (vo *CfProduct) SetProductDescription(productDescription string, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetProductDescription(productDescription: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockProductDescription.Lock()
	defer vo.Fields.RWLockProductDescription.Unlock()
	if vo.Fields.ProductDescription == nil {
		vo.Fields.ProductDescription = make(map[string]string)
	}
	vo.Fields.ProductDescription[string(loc)] = productDescription
	return
}

func (vo *CfProduct) SetSizetypecolor(sizetypecolor string, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetSizetypecolor(sizetypecolor: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockSizetypecolor.Lock()
	defer vo.Fields.RWLockSizetypecolor.Unlock()
	if vo.Fields.Sizetypecolor == nil {
		vo.Fields.Sizetypecolor = make(map[string]string)
	}
	vo.Fields.Sizetypecolor[string(loc)] = sizetypecolor
	return
}

func (vo *CfProduct) SetImage(image []ContentTypeSys, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetImage(image: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockImage.Lock()
	defer vo.Fields.RWLockImage.Unlock()
	if vo.Fields.Image == nil {
		vo.Fields.Image = make(map[string][]ContentTypeSys)
	}
	vo.Fields.Image[string(loc)] = image
	return
}

func (vo *CfProduct) SetTags(tags []string, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetTags(tags: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockTags.Lock()
	defer vo.Fields.RWLockTags.Unlock()
	if vo.Fields.Tags == nil {
		vo.Fields.Tags = make(map[string][]string)
	}
	vo.Fields.Tags[string(loc)] = tags
	return
}

func (vo *CfProduct) SetCategories(categories []ContentTypeSys, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetCategories(categories: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockCategories.Lock()
	defer vo.Fields.RWLockCategories.Unlock()
	if vo.Fields.Categories == nil {
		vo.Fields.Categories = make(map[string][]ContentTypeSys)
	}
	vo.Fields.Categories[string(loc)] = categories
	return
}

func (vo *CfProduct) SetPrice(price float64, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetPrice(price: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockPrice.Lock()
	defer vo.Fields.RWLockPrice.Unlock()
	if vo.Fields.Price == nil {
		vo.Fields.Price = make(map[string]float64)
	}
	vo.Fields.Price[string(loc)] = price
	return
}

func (vo *CfProduct) SetBrand(brand ContentTypeSys, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetBrand(brand: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockBrand.Lock()
	defer vo.Fields.RWLockBrand.Unlock()
	if vo.Fields.Brand == nil {
		vo.Fields.Brand = make(map[string]ContentTypeSys)
	}
	vo.Fields.Brand[string(loc)] = brand
	return
}

func (vo *CfProduct) SetSubProduct(subProduct ContentTypeSys, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetSubProduct(subProduct: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockSubProduct.Lock()
	defer vo.Fields.RWLockSubProduct.Unlock()
	if vo.Fields.SubProduct == nil {
		vo.Fields.SubProduct = make(map[string]ContentTypeSys)
	}
	vo.Fields.SubProduct[string(loc)] = subProduct
	return
}

func (vo *CfProduct) SetQuantity(quantity float64, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetQuantity(quantity: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockQuantity.Lock()
	defer vo.Fields.RWLockQuantity.Unlock()
	if vo.Fields.Quantity == nil {
		vo.Fields.Quantity = make(map[string]float64)
	}
	vo.Fields.Quantity[string(loc)] = quantity
	return
}

func (vo *CfProduct) SetSku(sku string, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetSku(sku: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockSku.Lock()
	defer vo.Fields.RWLockSku.Unlock()
	if vo.Fields.Sku == nil {
		vo.Fields.Sku = make(map[string]string)
	}
	vo.Fields.Sku[string(loc)] = sku
	return
}

func (vo *CfProduct) SetWebsite(website string, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetWebsite(website: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockWebsite.Lock()
	defer vo.Fields.RWLockWebsite.Unlock()
	if vo.Fields.Website == nil {
		vo.Fields.Website = make(map[string]string)
	}
	vo.Fields.Website[string(loc)] = website
	return
}

func (vo *CfProduct) SetSeoText(seoText interface{}, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetSeoText(seoText: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockSeoText.Lock()
	defer vo.Fields.RWLockSeoText.Unlock()
	if vo.Fields.SeoText == nil {
		vo.Fields.SeoText = make(map[string]interface{})
	}
	vo.Fields.SeoText[string(loc)] = seoText
	return
}

func (vo *CfProduct) SetNodes(nodes interface{}, locale ...Locale) (err error) {
	if vo == nil {
		return errors.New("SetNodes(nodes: Value Object is nil")
	}
	loc := DefaultLocale
	if len(locale) != 0 {
		loc = locale[0]
		if _, ok := localeFallback[loc]; !ok {
			return ErrLocaleUnsupported
		}
	}
	vo.Fields.RWLockNodes.Lock()
	defer vo.Fields.RWLockNodes.Unlock()
	if vo.Fields.Nodes == nil {
		vo.Fields.Nodes = make(map[string]interface{})
	}
	vo.Fields.Nodes[string(loc)] = nodes
	return
}

func (vo *CfProduct) UpsertEntry(ctx context.Context) (err error) {
	if vo == nil {
		return errors.New("UpsertEntry: Value Object is nil")
	}
	if vo.CC == nil {
		return errors.New("UpsertEntry: Value Object has nil Contentful client")
	}
	if vo.CC.clientMode != ClientModeCMA {
		return errors.New("UpsertEntry: Only available in ClientModeCMA")
	}
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("CfProduct UpsertEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("CfProduct UpsertEntry: Can't unmarshal JSON into CF entry")
	}

	err = vo.CC.Client.Entries.Upsert(ctx, vo.CC.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("CfProduct UpsertEntry: Operation failed: %w", err)
	}
	return
}
func (vo *CfProduct) PublishEntry(ctx context.Context) (err error) {
	if vo == nil {
		return errors.New("PublishEntry: Value Object is nil")
	}
	if vo.CC == nil {
		return errors.New("PublishEntry: Value Object has nil Contentful client")
	}
	if vo.CC.clientMode != ClientModeCMA {
		return errors.New("PublishEntry: Only available in ClientModeCMA")
	}
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("CfProduct PublishEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("CfProduct PublishEntry: Can't unmarshal JSON into CF entry")
	}
	err = vo.CC.Client.Entries.Publish(ctx, vo.CC.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("CfProduct PublishEntry: publish operation failed: %w", err)
	}
	return
}
func (vo *CfProduct) UnpublishEntry(ctx context.Context) (err error) {
	if vo == nil {
		return errors.New("UnpublishEntry: Value Object is nil")
	}
	if vo.CC == nil {
		return errors.New("UnpublishEntry: Value Object has nil Contentful client")
	}
	if vo.CC.clientMode != ClientModeCMA {
		return errors.New("UnpublishEntry: Only available in ClientModeCMA")
	}
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("CfProduct UnpublishEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("CfProduct UnpublishEntry: Can't unmarshal JSON into CF entry")
	}
	err = vo.CC.Client.Entries.Unpublish(ctx, vo.CC.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("CfProduct UnpublishEntry: unpublish operation failed: %w", err)
	}
	return
}
func (vo *CfProduct) UpdateEntry(ctx context.Context) (err error) {
	if vo == nil {
		return errors.New("UpdateEntry: Value Object is nil")
	}
	if vo.CC == nil {
		return errors.New("UpdateEntry: Value Object has nil Contentful client")
	}
	if vo.CC.clientMode != ClientModeCMA {
		return errors.New("UpdateEntry: Only available in ClientModeCMA")
	}
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("CfProduct UpdateEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("CfProduct UpdateEntry: Can't unmarshal JSON into CF entry")
	}

	err = vo.CC.Client.Entries.Upsert(ctx, vo.CC.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("CfProduct UpdateEntry: upsert operation failed: %w", err)
	}
	tmp, errMarshal = json.Marshal(cfEntry)
	if errMarshal != nil {
		return errors.New("CfProduct UpdateEntry: Can't marshal JSON back from CF entry")
	}
	errUnmarshal = json.Unmarshal(tmp, &vo)
	if errUnmarshal != nil {
		return errors.New("CfProduct UpdateEntry: Can't unmarshal JSON back into VO")
	}
	err = vo.CC.Client.Entries.Publish(ctx, vo.CC.SpaceID, cfEntry)
	if err != nil {
		return fmt.Errorf("CfProduct UpdateEntry: publish operation failed: %w", err)
	}
	return
}
func (vo *CfProduct) DeleteEntry(ctx context.Context) (err error) {
	if vo == nil {
		return errors.New("DeleteEntry: Value Object is nil")
	}
	if vo.CC == nil {
		return errors.New("DeleteEntry: Value Object has nil Contentful client")
	}
	if vo.CC.clientMode != ClientModeCMA {
		return errors.New("DeleteEntry: Only available in ClientModeCMA")
	}
	cfEntry := &contentful.Entry{}
	tmp, errMarshal := json.Marshal(vo)
	if errMarshal != nil {
		return errors.New("CfProduct DeleteEntry: Can't marshal JSON from VO")
	}
	errUnmarshal := json.Unmarshal(tmp, &cfEntry)
	if errUnmarshal != nil {
		return errors.New("CfProduct DeleteEntry: Can't unmarshal JSON into CF entry")
	}
	if cfEntry.Sys.PublishedCounter > 0 {
		errUnpublish := vo.CC.Client.Entries.Unpublish(ctx, vo.CC.SpaceID, cfEntry)
		if errUnpublish != nil && !strings.Contains(errUnpublish.Error(), "Not published") {
			return fmt.Errorf("CfProduct DeleteEntry: Unpublish entry failed: %w", errUnpublish)
		}
	}
	errDelete := vo.CC.Client.Entries.Delete(ctx, vo.CC.SpaceID, cfEntry.Sys.ID)
	if errDelete != nil {
		return fmt.Errorf("CfProduct DeleteEntry: Delete entry failed: %w", errDelete)
	}
	return nil
}
func (vo *CfProduct) ToReference() (refSys ContentTypeSys) {
	if vo == nil {
		return refSys
	}
	refSys.Sys.ID = vo.Sys.ID
	refSys.Sys.Type = FieldTypeLink
	refSys.Sys.LinkType = FieldLinkTypeEntry
	return
}

func (cc *ContentfulClient) cacheAllProduct(ctx context.Context, resultChan chan<- ContentTypeResult) (vos map[string]*CfProduct, err error) {
	if cc == nil || cc.Client == nil {
		return nil, errors.New("cacheAllProduct: No CDA/CPA client available")
	}
	var allProduct []*CfProduct
	col := &contentful.Collection{
		Items: []interface{}{},
	}
	cc.cacheMutex.sharedDataGcLock.RLock()
	defer cc.cacheMutex.sharedDataGcLock.RUnlock()
	if cc.offline {
		for _, entry := range cc.offlineTemp.Entries {
			if entry.Sys.ContentType.Sys.ID == ContentTypeProduct {
				col.Items = append(col.Items, entry)
			}
		}
	} else {
		col, err = cc.optimisticPageSizeGetAll(ctx, "product", cc.optimisticPageSize)
		if err != nil {
			return nil, errors.New("optimisticPageSizeGetAll for Product failed: " + err.Error())
		}
	}
	allProduct, err = colToCfProduct(col, cc)
	if err != nil {
		return nil, errors.New("colToCfProduct failed: " + err.Error())
	}
	productMap := map[string]*CfProduct{}
	for _, product := range allProduct {
		if cc.cacheInit {
			existingProduct, err := cc.GetProductByID(ctx, product.Sys.ID)
			if err == nil && existingProduct != nil && existingProduct.Sys.Version > product.Sys.Version {
				return nil, fmt.Errorf("cache update canceled because Product entry %s is newer in cache", product.Sys.ID)
			}
		}
		productMap[product.Sys.ID] = product
		result := ContentTypeResult{
			EntryID:     product.Sys.ID,
			ContentType: ContentTypeProduct,
			References:  map[string][]EntryReference{},
		}
		addEntry := func(id string, refs EntryReference) {
			if result.References[id] == nil {
				result.References[id] = []EntryReference{}
			}
			result.References[id] = append(result.References[id], refs)
		}
		_ = addEntry

		for _, loc := range cc.locales {
			children, okChildren := product.Fields.Categories[string(loc)]
			if okChildren {
				for _, child := range children {
					addEntry(child.Sys.ID, EntryReference{ContentType: product.Sys.ContentType.Sys.ID,
						ID:        product.Sys.ID,
						VO:        product,
						FromField: "categories",
					})
				}
			}
		}

		for _, loc := range cc.locales {
			child, okChild := product.Fields.Brand[string(loc)]
			if okChild {
				addEntry(child.Sys.ID, EntryReference{ContentType: product.Sys.ContentType.Sys.ID,
					ID:        product.Sys.ID,
					VO:        product,
					FromField: "brand",
				})
			}
		}

		for _, loc := range cc.locales {
			child, okChild := product.Fields.SubProduct[string(loc)]
			if okChild {
				addEntry(child.Sys.ID, EntryReference{ContentType: product.Sys.ContentType.Sys.ID,
					ID:        product.Sys.ID,
					VO:        product,
					FromField: "subProduct",
				})
			}
		}

		if ctx.Err() != nil {
			return nil, ctx.Err()
		}
		resultChan <- result
	}
	return productMap, nil
}

func (cc *ContentfulClient) cacheProductByID(ctx context.Context, id string, entryPayload *contentful.Entry, entryDelete bool) error {
	cc.cacheMutex.productGcLock.Lock()
	defer cc.cacheMutex.productGcLock.Unlock()
	cc.cacheMutex.idContentTypeMapGcLock.Lock()
	defer cc.cacheMutex.idContentTypeMapGcLock.Unlock()
	cc.cacheMutex.parentMapGcLock.Lock()
	defer cc.cacheMutex.parentMapGcLock.Unlock()
	cc.cacheMutex.genericEntriesGcLock.Lock()
	defer cc.cacheMutex.genericEntriesGcLock.Unlock()
	var col *contentful.Collection
	if entryPayload != nil {
		col = &contentful.Collection{
			Items: []interface{}{entryPayload},
		}
		id = entryPayload.Sys.ID
	} else {
		if cc.Client == nil {
			return errors.New("cacheProductByID: No client available")
		}
		if !entryDelete {
			col = cc.Client.Entries.List(ctx, cc.SpaceID)
			col.Query.ContentType("product").Locale("*").Include(0).Equal("sys.id", id)
			_, err := col.GetAll()
			if err != nil {
				return err
			}
		}
	}
	// It was deleted
	if col != nil && len(col.Items) == 0 || entryDelete {
		delete(cc.Cache.genericEntries, id)
		delete(cc.Cache.entryMaps.product, id)
		delete(cc.Cache.idContentTypeMap, id)
		// delete as child
		delete(cc.Cache.parentMap, id)
		// delete as parent
		for childID, parents := range cc.Cache.parentMap {
			newParents := []EntryReference{}
			for _, parent := range parents {
				if parent.ID != id {
					newParents = append(newParents, parent)
				}
			}
			cc.Cache.parentMap[childID] = newParents
		}
		return nil
	}
	vos, err := colToCfProduct(col, cc)
	if err != nil {
		return fmt.Errorf("cacheProductByID: Error converting %s to VO: %w", id, err)
	}
	product := vos[0]
	if cc.Cache.entryMaps.product == nil {
		cc.Cache.entryMaps.product = map[string]*CfProduct{}
	}
	cc.Cache.entryMaps.product[id] = product
	cc.Cache.genericEntries[id] = &GenericEntry{
		Sys:       product.Sys,
		RawFields: product.RawFields,
		CC:        product.CC,
	}
	cc.Cache.idContentTypeMap[id] = product.Sys.ContentType.Sys.ID
	allChildrensIds := map[string]bool{}

	for _, loc := range cc.locales {
		children, okChildren := product.Fields.Categories[string(loc)]
		if okChildren {
			for _, child := range children {
				allChildrensIds[child.Sys.ID] = true
				if cc.Cache.parentMap[child.Sys.ID] == nil {
					cc.Cache.parentMap[child.Sys.ID] = []EntryReference{}
				}
				newParentRef := EntryReference{ContentType: product.Sys.ContentType.Sys.ID, ID: product.Sys.ID, VO: product, FromField: "categories"}
				newParentSlice := []EntryReference{}
				for _, parent := range cc.Cache.parentMap[child.Sys.ID] {
					if parent.ID != id {
						newParentSlice = append(newParentSlice, parent)
					}
				}
				newParentSlice = append(newParentSlice, newParentRef)
				cc.Cache.parentMap[child.Sys.ID] = newParentSlice
			}
		}
	}

	for _, loc := range cc.locales {
		child, okChild := product.Fields.Brand[string(loc)]
		if okChild {
			allChildrensIds[child.Sys.ID] = true
			if cc.Cache.parentMap[child.Sys.ID] == nil {
				cc.Cache.parentMap[child.Sys.ID] = []EntryReference{}
			}
			newParentRef := EntryReference{ContentType: product.Sys.ContentType.Sys.ID, ID: product.Sys.ID, VO: product, FromField: "brand"}
			newParentSlice := []EntryReference{}
			for _, parent := range cc.Cache.parentMap[child.Sys.ID] {
				if parent.ID != id {
					newParentSlice = append(newParentSlice, parent)
				}
			}
			newParentSlice = append(newParentSlice, newParentRef)
			cc.Cache.parentMap[child.Sys.ID] = newParentSlice
		}
	}

	for _, loc := range cc.locales {
		child, okChild := product.Fields.SubProduct[string(loc)]
		if okChild {
			allChildrensIds[child.Sys.ID] = true
			if cc.Cache.parentMap[child.Sys.ID] == nil {
				cc.Cache.parentMap[child.Sys.ID] = []EntryReference{}
			}
			newParentRef := EntryReference{ContentType: product.Sys.ContentType.Sys.ID, ID: product.Sys.ID, VO: product, FromField: "subProduct"}
			newParentSlice := []EntryReference{}
			for _, parent := range cc.Cache.parentMap[child.Sys.ID] {
				if parent.ID != id {
					newParentSlice = append(newParentSlice, parent)
				}
			}
			newParentSlice = append(newParentSlice, newParentRef)
			cc.Cache.parentMap[child.Sys.ID] = newParentSlice
		}
	}

	_ = allChildrensIds // safety net
	// clean up child-parents that don't exist anymore
	for childID, parents := range cc.Cache.parentMap {
		if _, isCollectedChildID := allChildrensIds[childID]; isCollectedChildID {
			continue
		}
		newParents := []EntryReference{}
		for _, parent := range parents {
			if parent.ID != id {
				newParents = append(newParents, parent)
			}
		}
		cc.Cache.parentMap[childID] = newParents
	}
	return nil
}

func colToCfProduct(col *contentful.Collection, cc *ContentfulClient) (vos []*CfProduct, err error) {
	for _, item := range col.Items {
		var vo CfProduct
		byteArray, _ := json.Marshal(item)
		err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&vo)
		if err != nil {
			break
		}
		if cc.textJanitor {

			vo.Fields.ProductName = cleanUpStringField(vo.Fields.ProductName)

			vo.Fields.Slug = cleanUpStringField(vo.Fields.Slug)

			vo.Fields.ProductDescription = cleanUpStringField(vo.Fields.ProductDescription)

			vo.Fields.Sizetypecolor = cleanUpStringField(vo.Fields.Sizetypecolor)

			vo.Fields.Tags = cleanUpStringSliceField(vo.Fields.Tags)

			vo.Fields.Sku = cleanUpStringField(vo.Fields.Sku)

			vo.Fields.Website = cleanUpStringField(vo.Fields.Website)

			vo.Fields.SeoText = cleanUpRichTextField(vo.Fields.SeoText)

		}
		var typedItem RawItem
		err = json.NewDecoder(bytes.NewReader(byteArray)).Decode(&typedItem)
		if err != nil {
			break
		}
		vo.CC = cc
		vo.RawFields = typedItem.Fields
		vos = append(vos, &vo)
	}
	return vos, err
}
